We now move to the formalities for the PRISM language. To the best of
our knowledge, the only formalisation of a semantics for PRISM can be
found on the PRISM website~\cite{prismemantics}. Our approach starts
from this and attempts to make more precise some informal assumptions
and definitions.

\smallskip

\mypar{Syntax.} In this section, we will reuse some of the syntactic
terms used for our choreography language, including assignments and
expressions. We define the syntax of (a subset of) the PRISM language
as follows:
\begin{displaymath}
  \begin{array}{lrlll@{\qquad}l}
    \text{(Networks)}  \quad
    & N, M  & ::=  &      & \CEnd & \text{empty network}\\
    &       &      & \mid & \role{p}:\{F_i\}_i & \text{module}\\
%    &       &      & \mid & M \pp M    & \text{parallel composition}\\
    &       &      & \mid & M \ppp A M & \text{parallel composition}\\
    % &       &      & \mid & M/A        & \text{action hiding}\\
    % &       &      & \mid & \sigma M   & \text{substitution}\\
    \\
    \text{(Commands)}  \quad
    & F     & ::=  &      & \command \alpha g\lambda u
                                  & \text{} (\alpha\in\{\epsilon\}\cup\mathcal L) \\
    % \\[1mm]
    % \text{(Assignment)} \quad
    % & u     & ::=  &      & (x' = E) & \text{update $x$ % , element of $\mathcal V$, 
    %                                    with $E$}\\
    % &       &      & \mid & u\ \&\ u   & \text{multiple assignments}
    % \\[1mm]
    % \text{(Expr)}\quad
    % & E, g     & ::= &       & f(\tilde E)\quad\mid\quad x\quad\mid\quad v & \text{expressions}
    % % \\[1mm]
    % % \text{(Rates)}\quad   &     \lambda\in\mathbb R
    % %  \\[1mm]
    % %   \text{(Variables)}\quad &   x\in\mathsf{Var} 
    % %  \\[1mm]
    % %   \text{(Values)}\quad     &  v\in\mathsf{Val} 
  \end{array}
\end{displaymath}
Networks are the top syntactic category for system of modules composed
together. The term $\CEnd$ represent an empty network. A module is
meant to represent a process running in the system, and is denoted by
its role name and its commands, formally written as
$\role{p}:\{F_i\}_i$, where $\role p$ is a role and $F_i$ are
commands. Networks can be composed in parallel, in a CSP style: a term
like $M_1 \ppp A M_2$ says that networks $M_1$ and $M_2$ can
synchronise using labels in the finite set $A$.
%
In this work, we omit PRISM hiding and substitution as they are
irrelevant for our current choreography language.
% The term $M/A$ is the standard CSP/CCS hiding operator. Finally
% $\sigma M$ is equivalent to applying the substitution $\sigma$ to
% all variables in $x$. A substitution is a function that given a
% variable returns a value. When we write $\sigma N$ we refer to the
% term obtained by replacing every free variable $x$ in $N$ with
% $\sigma(x)$. \marco{Is this really the way substitution is used?
% Where does it become important?}
%
Commands in a module have the form
$[\alpha] g \rightarrow \Sigma_{i\in I}\{\lambda_i: u_i\}$. The label
$\alpha$ can either be the empty string $\epsilon$ or a label $a$,
i.e., $\alpha\in\{\epsilon\}\cup \mathcal L$. If $\epsilon$ then no
synchronisation is required. On the other hand, if there is label $a$
then there will be a synchronisation with other modules that must
synchronise on $a$. The term $g$ is a guard on the current variable
state. If both label and guard are enabled, then the command executes
a branch $i$ with probability/rate $\lambda_i$. As for choreographies,
if the $\lambda_i$'s are probabilities, we must have that
$\Sigma_{i\in I}\lambda_i=1$.

\mypar{Semantics.} In order to give a probabilistic semantics to the
PRISM language, we follow the approach given in the PRISM
website~\cite{prismemantics}.  Hereby, we do that by defining two
relations: one with labels for networks and one on states. Our
relation on networks is the minimum relation $\prismred{}{}$
satisfying the rules given in Figure~\ref{fig:semantics}.
% 
\begin{figure}[t]
  \begin{displaymath}\small
    \begin{array}{ccc}
      \infer[\mathsf{(M)}]
      { {\role{p}:\{F_k\}_k} \prismred{} F
      % {\alpha}\lab{g}{\Sigma_{i\in I}\lambda_i\!}{u_i} 
      }
      {
      % \command {\alpha}g\lambda u
      F\in\{F_k\}_k
      }
      \quad
      \infer[\mathsf{(P_1)}]
      {M_1\ppp A M_2\prismred{}\command {\alpha}g\lambda u
      % {\alpha}\lab{g}{\Sigma_{i\in I}\lambda_i\!}{u_i}
      }
      {
      \exists j\in\{1,\!2\}.\ 
      M_j\prismred{} \command {\alpha}g\lambda u
      % {\alpha}\lab{g}{\Sigma_{i\in I}\lambda_i\!}{u_i}
      & \alpha\!\not\in\! A
        }
      \\\\
      \infer[\mathsf{(P_2)}]
      {M_1\ppp A M_2\prismred{}
      \commandBase a{g\land g'}
      {\Sigma_{i,j}\,\lambda_i*\lambda_j}: {u_i\& u_j} 
      }
      {
      M_1\prismred{}\command {\alpha}g\lambda u
      % {a}\lab{g}{\Sigma_{i\in I}\lambda_i}{\!u_i} 
      \quad&\quad 
        M_2\prismred{}\commandBase {\alpha} {g'} \Sigma_{j\in J}\lambda_j: u'_j
        % {a}\lab{g'}{\Sigma_{j\in J}\lambda'_j}{\!u'_j} 
      \ &\
             a\!\in\! A}
    \end{array}
  \end{displaymath}
  \caption{Semantics for PRISM networks} 
  \label{fig:semantics}
\end{figure}
Rule $\mathsf{(M)}$ just exposes a command at network level. Rule
$\mathsf{(P_1)}$ propagates a command through parallel composition if
$\alpha$ is empty or if the label $a$ is not part of the set $A$. When
the label $a$ is in $A$, we apply rule $\mathsf{(P_2)}$. In this case,
the product of the probabilities/rates must be taken by extending the
two different branches to every possible combination. 

Based on the relation above, given
$M\prismred{}\command \alpha g\lambda u$ and two
states $S$ and $S'$, we define the function
$$\mu(\command \alpha g\lambda u,\ S,\ S'\ ) = \Sigma_{S[u_i]=S',i\in I}\lambda_i$$
which gives the probability/rate for the system to go from state $S$
to state $S'$ after executing command $\command \alpha g \lambda u$,
for some $\alpha$.
%
If the $\lambda_i$ are probabilities, then the function must be a
probability distribution. Note that $\mu(F,S,S')$ only denotes the
probability/rate for the system to move from state $S$ to state $S'$
after executing command $F$. However, there could be several commands
derived from $M$ through the relation $\prismred{}$ that could be
executed to move from $S$ to $S'$. Therefore, we define the transition
relation on states $M\vdash S\red{\lambda}S'$ as
$$
\infer[\mathsf{(Transition)}]
{
  M\vdash S\red{\sum_{j} \mu(F_j,S,S')}S'
  % M\vdash S\red{\sum_{S'= S[u_j]} \lambda_j}S'
}
{
  \forall j,\alpha.\ M\prismred{}F_j
  % \command{\alpha_j} {g_j}{{\lambda_j}} {{u_j}}
  \quad&\quad
  S\vdash F_j
}
$$
where $S\vdash \command \alpha g\lambda u$ is defined as $\eval gS$.
Note that given the declarative aspect of the PRISM language, the
syntax is constant and never changes.

It is important to point out that, in general, the transition rule
above does not give the exact probability of a transition in case of a
Markov chain (DTMC), since the sum ${\sum_{j} \mu(F_j,S,S')}$ could be
a value greater than $1$. In order to get the right probability, the
value has to be normalised for all reachable $S'$. In the next
section, we will show that this is not an issue for networks that are
obtained from our translation from choreography to PRISM.

% At this point, we need to make a first observation about this
% construction whenever we are using probabilities [PUT NORMALISATION
% CONSTRAINT HERE].
% % Then, we define the transition relation $M\vdash S\red{\lambda}S'$ as
% % follows Note that if the $\lambda$'s are probabilities, hence, we deal
% % with an DTMC, then the probabilities of the branches outgoing from a
% % give state $S$ must be normalised -- this is because the sum at the
% % bottom of the $\mathsf{Transition}$ rule can be more than one. This is
% % not the case if we have a CTMC with rates.

\begin{example}
  Consider the following network:
\end{example}

% SEMANTICS WITH GUESS (Early)
%
% \begin{figure}[t]
%   \begin{displaymath}\small
%     \begin{array}{ccc}
%       \infer[\mathsf{(M_1)}]
%       { {\role{p}:\{F_k\}_k} \prismred{}\lab{g}{\lambda_i}{u_i} }
%       {\command {}g\lambda u\in\{F_k\}_k}
%       \qquad
%       \infer[\mathsf{(P_1)}]
%       {M_1\ppp A M_2\prismred{\alpha}\lab g\lambda u }
%       {
%       \exists j\in\{1,2\}.\ 
%       M_j\prismred{\alpha}\lab g\lambda u
%       & \alpha\not\in A
%         }
%       \\\\
%       \infer[\mathsf{(M_2)}]
%       { {\role{p}:\{F_k\}_k} \prismred{a}\lab{g}{\lambda_i\!\!}{u_i} }
%       {\command ag\lambda u\in\{F_k\}_k}
%       \quad
%       \infer[\mathsf{(P_2)}]
%       {M_1\ppp A M_2\prismred{a}\lab{g_1\land g_2}{\lambda_1*\lambda_2\!\!}{u_1\& u_2} }
%       {
%       M_1\!\!\!\prismred{a}\!\!\!\lab{g_1}{\lambda_1\!\!}{\!\!u_1} 
%       & M_2\!\!\!\prismred{a}\!\!\!\lab{g_2}{\lambda_2\!\!}{\!\!u_2} 
%       & a\!\in\! A}
%     \end{array}
%   \end{displaymath}
%   \caption{LTS for PRISM networks} 
%   \label{fig:semantics}
% \end{figure}

%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "main"
%%% End: