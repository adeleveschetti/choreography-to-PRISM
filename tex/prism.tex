This section provides the formal definition of our choreographic
language as well as process algebra representing
PRISM~\cite{prismsemantics}.

\subsection{PRISM} We start by describing PRISM semantics. To the best
of our knowledge, the only formalisation of a semantics for PRISM can
be found on the PRISM website~\cite{prismemantics}. Our approach
starts from this and attempts to make more precise some informal
assumptions and definitions.

\smallskip

\mypar{Syntax.} Let $\role p$ range over a (possibly infinite) set of
module names $\mathcal R$, $a$ over a (possibly infinite) set of
labels $\mathcal L$, $x$ over a (possibly infinite) set of variables
$\mathsf{Var}$, and $v$ over a (possibly infinite) set of values
$\mathsf{Val}$. Then, the syntax of the PRISM language is given by the
following grammar:
\begin{displaymath}
  \begin{array}{lrllll}
    \text{(Networks)}  \quad
    & N, M  & ::=  &      & \CEnd & \text{empty network}\\
    &       &      & \mid & \role{p}:\{F_i\}_i & \text{module}\\
%    &       &      & \mid & M \pp M    & \text{parallel composition}\\
    &       &      & \mid & M \ppp A M & \text{parallel composition}\\
    &       &      & \mid & M/A        & \text{action hiding}\\
    &       &      & \mid & \sigma M   & \text{substitution}\\
    \\
    \text{(Commands)}  \quad
    & F     & ::=  &      & \command ag\lambda u
                                  & \text{$g$ is a boolean expression in $E$} \\
    \\[1mm]
    \text{(Assignment)} \quad
    & u     & ::=  &      & (x' = E) & \text{update $x$, element of $\mathcal V$, with $E$}\\
    &       &      & \mid & A \& A   & \text{multiple assignments}
    \\[1mm]
    \text{(Expr)}\quad
    & E     & ::= &       & f(\tilde E)\quad\mid\quad x\quad\mid\quad v
    % \\[1mm]
    % \text{(Rates)}\quad   &     \lambda\in\mathbb R
    %  \\[1mm]
    %   \text{(Variables)}\quad &   x\in\mathsf{Var} 
    %  \\[1mm]
    %   \text{(Values)}\quad     &  v\in\mathsf{Val} 
  \end{array}
\end{displaymath}
Networks are the top syntactic category for system of modules composed
together. The term $\CEnd$ represent an empty network. A module is
meant to represent a process running in the system, and is denoted by
its variables and its commands. Formally, a module
$\role{p}:\{F_i\}_i$ is identified by its name $\role p$ and a set of
commands $F_i$. Networks can be composed in parallel, in a CSP style:
a term like $M_1 \ppp A M_2$ says that networks $M_1$ and $M_2$ can
interact with each other using labels in the finite set $A$. The term
$M/A$ is the standard CSP/CCS hiding operator. Finally $\sigma M$ is
equivalent to applying the substitution $\sigma$ to all variables in
$x$. A substitution is a function that given a variable returns a
value. When we write $\sigma N$ we refer to the term obtained by
replacing every free variable $x$ in $N$ with $\sigma(x)$. \marco{Is
  this really the way substitution is used? Where does it become
  important?}  Commands in a module have the form
$[a] g \rightarrow \Sigma_{i\in I}\{\lambda_i: u_i\}$. The label $a$
is used for synchronisation (it is a condition that allows the command
to be executed when all other modules having a command on the same
label also execute).  The term $g$ is a guard on the current variable
state. If both label and the guards are enabled, then the command
executes in a probabilistic way one of the branches.  Depending on the
model we are going to use, the value $\lambda_j$ is either a real
number representing a rate (when adapting an exponential distribution)
or a probability. If we are using probabilities, then we assume that
terms in every choice are such that the sum of the probabilities is
equal to 1.

\mypar{Semantics.} In order to give a probabilistic semantics to
PRISM, we proceed by steps. First, we define $\sem{-}$, as the closure
of the following rules:
% 
\begin{displaymath}\small
  \begin{array}{ccc}
    \infer[\mathsf{(Module)}]
    {F_i\in\sem{\role{p}:\{F_i\}_i}}
    {}
    \qquad
    \infer[\mathsf{(Par_1)}]
    {\cmd{}E{\lambda_i}{x_i}{E_i}{i\in I}\in \sem{M_1\ppp A M_2}}
    {\cmd{}E{\lambda_i}{x_i}{E_i}{i\in I}\in \sem{M_j}
    & j\in\{1,2\}}
    \\\\
    \infer[\mathsf{(Par_2)}]
    {\cmd aE{\lambda_i}{x_i}{E_i}{i\in I}\in \sem{M_1\ppp A M_2}}
    {\cmd aE{\lambda_i}{x_i}{E_i}{i\in I}\in \sem{M_j}
    & a\not\in A    & j\in\{1,2\}}
    \\\\
    \infer[\mathsf{(Par_3)}]
    {
    [] E\land E' \rightarrow \{\lambda_i * \lambda_j': x_i = E_i \land y_j = E_j' \}_{i\in I, j\in J}
    \in \sem{M_1\ppp A M_2}
    }
    {\cmd aE{\lambda_i}{x_i}{E_i}{i\in I}\in \sem{M_1}{}
    & \cmd a{E'}{\lambda_j'}{y_j}{E_j'}{j\in J}\in \sem{M_2}{}
    & a\in A}
    \\\\
    \infer[\mathsf{(Hide_1)}]
    {
    \cmd {}E{\lambda_j}{x_i}{E_i}{i\in I}\in \sem{M/A}{}
    }
    {
    \cmd {}E{\lambda_j}{x_i}{E_i}{i\in I}\in \sem{M}{}
    }
    \qquad
    \infer[\mathsf{(Hide_2)}]
    {
    \cmd {a}E{\lambda_j}{x_i}{E_i}{i\in I}\in \sem{M/A}{}
    }
    {
    \cmd {a}E{\lambda_j}{x_i}{E_i}{i\in I}\in \sem{M}{}
    & a\not\in A
      }
    \\\\
    \infer[\mathsf{(Hide_3)}]
    {
    \cmd {}E{\lambda_j}{x_i}{E_i}{i\in I}\in \sem{M/A}{}
    }
    {
    \cmd {a}E{\lambda_j}{x_i}{E_i}{i\in I}\in \sem{M}{}
    & a\in A
      }
      \qquad
      \infer[\mathsf{(Subst_1)}]
      {
      \cmd {}E{\lambda_j}{x_i}{E_i}{i\in I}\in \sem{\sigma M}{}
      }
      {
      \cmd {}E{\lambda_j}{x_i}{E_i}{i\in I}\in \sem{M}{}
      }
    \\\\
    \infer[\mathsf{(Subst_2)}]
    {
    \cmd {a}E{\lambda_j}{x_i}{E_i}{i\in I}\in \sem{\sigma M}{}
    }
    {
    \cmd {a}E{\lambda_j}{x_i}{E_i}{i\in I}\in \sem{M}{}
    & a\not\in\mathsf{dom}(\sigma)
      }
    \\\\
    \infer[\mathsf{(Subst_3)}]
    {
    \cmd {\sigma a}E{\lambda_j}{x_i}{E_i}{i\in I}\in \sem{\sigma M}{}
    }
    {
    \cmd {a}E{\lambda_j}{x_i}{E_i}{i\in I}\in \sem{M}{}
    & a\in\mathsf{dom}(\sigma)
      }
  \end{array}
\end{displaymath}
The rules above work with modules, parallel composition, name hiding,
and substitution. The idea is that given a network, we wish to collect
all those commands $F$ that are contained in the network,
independently from which module they are being executed
in. Intuitively, we can regard $\sem{N}$ as a set, where starting from
all commands present in the syntax, we do some filtering and renaming,
based on the structure of the network.

Now, given $\sem N$, we define a transition system that shows how the
system evolves.  Let $\state$ be a function that given a variable in
$\mathsf{Var}$ returns a value in $\mathsf{Val}$. Then, given an
initial state $\state_0$, we can define a transition system where each
of node is a (different) $\state$ function. Then, we can move from
$\state_1$ to $\state_2$ whenever ... Formally, a transition system is
defined as:
\begin{definition}[Transition System] 
  [put definition of transition system here. ]
\end{definition}
We can then define a transition system
$\mathcal T = (2^\state,\state_0,\ldots)$ [fix details here].

\begin{definition}[Discrete Time Markov Chain (DTMC)]
  A Discrete Time Markov Chain (DTMC) is a pair $(S,P)$ where
  \begin{itemize}
  \item $S$ is a set of states
  \item $P: S\times S \rightarrow [0,1]$ is the probability transition
    matrix such that, for all $s\in S$, $\sum_{s'\in S}P(s,s')=1$.
  \end{itemize}
\end{definition}

\begin{definition}[Continuous Time Markov Chain (CTMC)]
  A Continuous Time Markov Chain (DTMC) is a pair $(S,R)$ where
  \begin{itemize}
  \item $S$ is a set of states
  \item $P: S\times S \rightarrow \mathbb R^{\geq 0}$ is the rate
    transition matrix.
  \end{itemize}
\end{definition}



%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "main"
%%% End: