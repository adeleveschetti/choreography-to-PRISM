\mypar{Syntax.} This is the language and we comment on it later.


\noindent {\em Global:}

\begin{displaymath}
  \begin{array}{lll}
    \text{(Chor)}  \quad & C \ ::=\ & \role p\longrightarrow\{\role p_i\}_{i\in I}\oplus\{[\lambda_j] x_j=E_j: C_j\}_{j\in J}\ \mid\
    \textsf{if } E@\role{p} \textsf{ then } C_1 \textsf{ else } C_2 \ \mid\ X\ \mid\ \CEnd\\\\
    \text{(Expressions)}\quad & E \ ::=\ & f(\tilde E)\quad\mid\quad x\\\\
    \text{(Rates)}\quad       & \lambda\in\mathbb R
  \end{array}
\end{displaymath}


\noindent {\em Prism/Local:} 
\begin{displaymath}
  \begin{array}{lll}
    \text{(Networks)}  \quad & N \ ::=\ & \CEnd \ \mid\ \role{p}:\{F_i\}_i\ \mid\ M \pp M\ \mid\ M \ppp A M\ \mid\ M/A\ \mid\ \sigma M\\\\
    \text{(Commands)}  \quad & F \ ::=\ & \cmd aE{\lambda_i}{x_i}{E_i}{i\in I}\\\\
  \end{array}
\end{displaymath}

\mypar{Semantics.} We construct by the following set of rules:

\begin{displaymath}
  \begin{array}{lll}
    \infer[]
    {\cmd{}E{\lambda_i}{x_i}{E_i}{i\in I}\in \sem{M_1\ppp A M_2}}
    {\cmd{}E{\lambda_i}{x_i}{E_i}{i\in I}\in \sem{M_j}
    & j\in\{1,2\}}
    \\\\
    \infer[]
    {\cmd aE{\lambda_i}{x_i}{E_i}{i\in I}\in \sem{M_1\ppp A M_2}}
    {\cmd aE{\lambda_i}{x_i}{E_i}{i\in I}\in \sem{M_j}
    & a\not\in A    & j\in\{1,2\}}
    \\\\
    \infer[]
    {
    [a] E\land E' \rightarrow \{\lambda_i * \lambda_j': x_i = E_i \land x_j' = E_j' \}_{i\in I, j\in J}
    \in \sem{M_1\ppp A M_2}
    }
    {\cmd aE{\lambda_j}{x_i}{E_i}{i\in I}\in \sem{M_1}{}
    & \cmd a{E'}{\lambda_j}{x_j'}{E_j'}{j\in J}\in \sem{M_2}{}
    & a\in A}
  \end{array}
\end{displaymath}

\begin{displaymath}
  \begin{array}{lll}
    W(M) = \{F \mid F\in\sem{M}\}
    \\\\
    X = \{x_1,\ldots,x_n\}
    \\\\
    \sigma : X \rightarrow V
  \end{array}
\end{displaymath}



\mypar{Mapping Choreographies to PRISM.} We need to run some standard
static checks because, since there is branching, some terms may not be
projectable.


$f: C\rightarrow \mathcal R\mapsto F$
\[
\begin{array}{l}
f(\role p_1\longrightarrow\{\role p_i\}_{i\in I}\oplus\{[\lambda_j]
x_j=E_j: C_j\}_{j\in J}) = \\
= \begin{cases}
\bigg( [\lambda_{j_1}] x_{j_1} = f(E_{j_1}) \bigg)_{\role p}. f(\oplus\{[\lambda_j]
x_j=E_j: C_j\}_{j\in J\setminus\{{j_1}\}}). f(C_{j_1}) &if \ \role p = \role p_1 \lor \role p \in \role \{\role p_i\}_{i \in I} \\
%\big|[\lambda_j] x_j = f(E_j)\big|_{\role p} . f(C_j) &if\ \role p \in \role \{\role p_i\}_{i \in I}\\
f(C_j) & if \ \role p \neq \role p_1 \land \role p \notin \{\role p_i\}_{i\in I}
\end{cases} 
\\
f(\textsf{if } E@\role{p} \textsf{ then } C_1 \textsf{ else } C_2) = \begin{cases}
f(E) . f(C_1) . f(C_2) & if\ \role p\in \mathbf{roles}\\
\bot & otherwise
\end{cases} 
\\
f(X) = \; ??
\\
f(\CEnd) = \bot
\end{array}
\]


%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "main"
%%% End:
