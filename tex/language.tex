In this section, we provide the formal definition of our choreographic
language as well as process algebra representing
PRISM~\cite{prismsemantics}.


\subsection{PRISM} We start by describing PRISM semantics. Except from
transforming some informal text in precise rules, Our formalisation
closely follows that found on the PRISM website~\cite{prismemantics}.

\smallskip

\mypar{Syntax.} Let $\role p$ range over a (possibly infinite) set of
module names $\mathcal R$, $a$ over a (possibly infinite) set of
labels $\mathcal L$, $x$ over a (possibly infinite) set of variables
$\mathsf{Var}$, and $v$ over a (possibly infinite) set of values
$\mathsf{Val}$. Then, the syntax of PRISM is given by the following
grammar:
\begin{displaymath}
  \begin{array}{lrllll}
    \text{(Networks)}  \quad
    & N, M  & ::=  &      & \CEnd & \text{empty network}\\
    &       &      & \mid & \role{p}:\{F_i\}_i & \text{module}\\
%    &       &      & \mid & M \pp M    & \text{parallel composition}\\
    &       &      & \mid & M \ppp A M & \text{parallel composition}\\
    &       &      & \mid & M/A        & \text{action hiding}\\
    &       &      & \mid & \sigma M   & \text{substitution}\\
    \\
    \text{(Commands)}  \quad
    & F     & ::=  &      & [a] g \rightarrow \Sigma_{i\in I}\{\lambda_i: u_i\}
                                  & \text{$g$ is a boolean expression in $E$} \\
    \\[1mm]
    \text{(Assignment)} \quad
    & u     & ::=  &      & (x' = E) & \text{update $x$, element of $\mathcal V$, with $E$}\\
    &       &      & \mid & A \& A   & \text{multiple assignments}
    \\[1mm]
    \text{(Expr)}\quad
    & E     & ::= &       & f(\tilde E)\quad\mid\quad x\quad\mid\quad v
    % \\[1mm]
    % \text{(Rates)}\quad   &     \lambda\in\mathbb R
    %  \\[1mm]
    %   \text{(Variables)}\quad &   x\in\mathsf{Var} 
    %  \\[1mm]
    %   \text{(Values)}\quad     &  v\in\mathsf{Val} 
  \end{array}
\end{displaymath}
Networks are the top syntactic category for system of modules composed
together. The term $CEnd$ represent an empty network. A module
$\role{p}:\{F_i\}_i$ is identified by its name $\role p$ and a set of
commands $F_i$. Networks can be composed in parallel, in a CSP style:
a term like $M_1 \ppp A M_2$ says that networks $M_1$ and $M_2$ can
interact with each other using labels in the finite set $A$. The term
$M/A$ is the standard CSP/CCS hiding operator. Finally $\sigma M$ is
equivalent to applying the substitution $\sigma$ to all variables in
$x$. A substitution is a function that given a variable returns a
value. When we write $\sigma N$ we refer to the term obtained by
replacing every free variable $x$ in $N$ with $\sigma(x)$. \marco{Is
  this really the way substitution is used? Where does it become
  important?}


\mypar{Semantics.} We construct all the enables commands by applying a
closure to the following rules.
% 
\begin{displaymath}
  \begin{array}{lll}
    \infer[]
    {\cmd{}E{\lambda_i}{x_i}{E_i}{i\in I}\in \sem{M_1\ppp A M_2}}
    {\cmd{}E{\lambda_i}{x_i}{E_i}{i\in I}\in \sem{M_j}
    & j\in\{1,2\}}
    \\\\
    \infer[]
    {\cmd aE{\lambda_i}{x_i}{E_i}{i\in I}\in \sem{M_1\ppp A M_2}}
    {\cmd aE{\lambda_i}{x_i}{E_i}{i\in I}\in \sem{M_j}
    & a\not\in A    & j\in\{1,2\}}
    \\\\
    \infer[]
    {
    [a] E\land E' \rightarrow \{\lambda_i * \lambda_j': x_i = E_i \land x_j' = E_j' \}_{i\in I, j\in J}
    \in \sem{M_1\ppp A M_2}
    }
    {\cmd aE{\lambda_j}{x_i}{E_i}{i\in I}\in \sem{M_1}{}
    & \cmd a{E'}{\lambda_j}{x_j'}{E_j'}{j\in J}\in \sem{M_2}{}
    & a\in A}
  \end{array}
\end{displaymath}
That means that ones we have a set of executable rules, we can start
building a transition system. In order to do so, we


\begin{displaymath}
  \begin{array}{lll}
    W(M) = \{F \mid F\in\sem{M}\}
    \\\\
    X = \{x_1,\ldots,x_n\}
    \\\\
    \sigma : X \rightarrow V
  \end{array}
\end{displaymath}




\newpage


\subsection{Choreographies}

\mypar{Syntax.} Our choreographic language is defined by the following
syntax:
%
\begin{displaymath}
  \begin{array}{lll}
    \text{(Chor)}  \quad & C \ ::=\
    & \{\role p_i\}_{i\in I}\,+\!\{\lambda_j: x_j=E_j;\ C_j\}_{j\in J}
      \ \mid\
      \textsf{if } E@\role{p} \textsf{ then } C_1 \textsf{ else } C_2
      \ \mid\
      X
      \ \mid\
      \CEnd
  \end{array}
\end{displaymath}
We briefly comment the various constructs. The syntactic category $C$
denotes choreographic programmes. The term
$\{\role p_i\}_{i\in I}\,+\!\{\lambda_j: x_j=E_j;\ C_j\}_{j\in J}$
denotes an interaction between the roles $\role p_i$. The value
$\lambda_j$ is a real number representing the rate. ...



\subsection{Projection from Choreographies to PRISM}
\mypar{Mapping Choreographies to PRISM.} We need to run some standard
static checks because, since there is branching, some terms may not be
projectable.
%

\begin{comment}
\begin{displaymath}
  \begin{array}{ll}
    f\Big(\quad \role p_1\longrightarrow\{\role p_2\} \oplus
    \left\{
    \begin{array}{l}{}
      [\lambda_1] x=5:  \role p_1\longrightarrow\{\role p_2\} \oplus\{[\lambda_3] y=5\}
      \\{}
      [\lambda_2] y=10: \role p_1\longrightarrow\{\role p_2\} \oplus\{[\lambda_4] x=10\}
    \end{array}
    \right\}
    , \ \role p_1:\emptyset\ \pp\ \role p_2:\emptyset
    \Big)
    \\\\
    =
    \\\\
    \text{label} = \text{newlabel}();\\
    \text{for } \role p_i \{\\
    \ add(p_i, [\text{label}] {s_{p_i} = state(p_i)} \rightarrow\
    \left\{
    \begin{array}{ll}
      \lambda_1: x'=5; \textsf{state}(\role p_i)' = \textsf{generatenewstate} (\role p_i)
      \\
      \lambda_2: y'=10; \textsf{state}(\role p_i)' = \textsf{generatenewstate} (\role p_i)
    \end{array}
    \right\}
    \\

    \ f(\role p_1\longrightarrow\{\role p_2\} \oplus\{[\lambda_3] y=5\}, network') = network''\\
    \ return f(\role p_1\longrightarrow\{\role p_2\} \oplus\{[\lambda_4] x=10\}, network'')
    
  \end{array}
\end{displaymath}

\hrule
\end{comment}

\begin{displaymath}
	f : C \longrightarrow \texttt{network} \longrightarrow \texttt{network} \quad\quad \texttt{network} : \mathcal R \longrightarrow \text{Set}(F)
\end{displaymath}

\begin{displaymath}
  \begin{array}{ll}
    f\Big(\; \role p_1\longrightarrow\{\role
 p_i\}_{i\in I} \oplus \{[\lambda_j] x_j=E_j: D_j\}_{j\in J}, \texttt{network}
    \Big)
    \\\\
    =
    \\\\
    \textsf{label} = \texttt{newlabel}();\\
    \textsf{for } \role p_k \in \mathbf{roles} \{\\
    \quad\textsf{for } j \in J \{\\
    \quad\quad \texttt{network} = \texttt{add}(\role p_k,[\textsf{label}] {s_{\role p_k} = \texttt{state}(\role p_k)} \rightarrow\ \lambda_j : x_j=E_j\;\& \;s_{\role p_k}'=\texttt{genNewState}(\role p_k));\\
  	\quad\}\\
  	\}\\
	\textsf{for } j \in J \{\\
	\quad \texttt{network} = f(D_j, \texttt{network});  \\ 
	\}\\
  	\textsf{return } \texttt{network}
  \end{array}
\end{displaymath}

\begin{displaymath}
  \begin{array}{ll}
    f\Big(\; \textsf{if } E@\role{p} \textsf{ then } C_1 \textsf{ else } C_2, \texttt{network} 
    \Big)
    \\\\
    =
    \\\\
\texttt{network} = \texttt{add}(\role p,[\;] {s_{\role p} = \texttt{state}(\role p)} \;\& \;f(E));\\
	\texttt{network} = f(C_1, \texttt{network}); \\
	\texttt{network} = f(C_2, \texttt{network}); \\

 	\text{return } \texttt{network}
  \end{array}
\end{displaymath}


%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "main"
%%% End:
