This section provides the formal definition of our choreographic
language as well as process algebra representing
PRISM~\cite{prismsemantics}.

\subsection{PRISM} We start by describing PRISM semantics. To the best
of our knowledge, the only formalisation of a semantics for PRISM can
be found on the PRISM website~\cite{prismemantics}. Our approach
starts from this and attempts to make more precise some informal
assumptions and definitions.

\smallskip

\mypar{Syntax.} Let $\role p$ range over a (possibly infinite) set of
module names $\mathcal R$, $a$ over a (possibly infinite) set of
labels $\mathcal L$, $x$ over a (possibly infinite) set of variables
$\mathsf{Var}$, and $v$ over a (possibly infinite) set of values
$\mathsf{Val}$. Then, the syntax of the PRISM language is given by the
following grammar:
\begin{displaymath}
  \begin{array}{lrllll}
    \text{(Networks)}  \quad
    & N, M  & ::=  &      & \CEnd & \text{empty network}\\
    &       &      & \mid & \role{p}:\{F_i\}_i & \text{module}\\
%    &       &      & \mid & M \pp M    & \text{parallel composition}\\
    &       &      & \mid & M \ppp A M & \text{parallel composition}\\
    &       &      & \mid & M/A        & \text{action hiding}\\
    &       &      & \mid & \sigma M   & \text{substitution}\\
    \\
    \text{(Commands)}  \quad
    & F     & ::=  &      & \command ag\lambda u
                                  & \text{$g$ is a boolean expression in $E$} \\
    \\[1mm]
    \text{(Assignment)} \quad
    & u     & ::=  &      & (x' = E) & \text{update $x$, element of $\mathcal V$, with $E$}\\
    &       &      & \mid & A \& A   & \text{multiple assignments}
    \\[1mm]
    \text{(Expr)}\quad
    & E     & ::= &       & f(\tilde E)\quad\mid\quad x\quad\mid\quad v
    % \\[1mm]
    % \text{(Rates)}\quad   &     \lambda\in\mathbb R
    %  \\[1mm]
    %   \text{(Variables)}\quad &   x\in\mathsf{Var} 
    %  \\[1mm]
    %   \text{(Values)}\quad     &  v\in\mathsf{Val} 
  \end{array}
\end{displaymath}
Networks are the top syntactic category for system of modules composed
together. The term $\CEnd$ represent an empty network. A module is
meant to represent a process running in the system, and is denoted by
its variables and its commands. Formally, a module
$\role{p}:\{F_i\}_i$ is identified by its name $\role p$ and a set of
commands $F_i$. Networks can be composed in parallel, in a CSP style:
a term like $M_1 \ppp A M_2$ says that networks $M_1$ and $M_2$ can
interact with each other using labels in the finite set $A$. The term
$M/A$ is the standard CSP/CCS hiding operator. Finally $\sigma M$ is
equivalent to applying the substitution $\sigma$ to all variables in
$x$. A substitution is a function that given a variable returns a
value. When we write $\sigma N$ we refer to the term obtained by
replacing every free variable $x$ in $N$ with $\sigma(x)$. \marco{Is
  this really the way substitution is used? Where does it become
  important?}  Commands in a module have the form
$[a] g \rightarrow \Sigma_{i\in I}\{\lambda_i: u_i\}$. The label $a$
is used for synchronisation (it is a condition that allows the command
to be executed when all other modules having a command on the same
label also execute).  The term $g$ is a guard on the current variable
state. If both label and the guards are enabled, then the command
executes in a probabilistic way one of the branches.  Depending on the
model we are going to use, the value $\lambda_j$ is either a real
number representing a rate (when adapting an exponential distribution)
or a probability. If we are using probabilities, then we assume that
terms in every choice are such that the sum of the probabilities is
equal to 1.

\mypar{Semantics.} In order to give a probabilistic semantics to
PRISM, we proceed by steps. First, we define $\sem{-}$, as the closure
of the following rules:
% 
\begin{displaymath}\small
  \begin{array}{ccc}
    \infer[\mathsf{(Module)}]
    {F_i\in\sem{\role{p}:\{F_i\}_i}}
    {}
    \qquad
    \infer[\mathsf{(Par_1)}]
    {\cmd{}E{\lambda_i}{x_i}{E_i}{i\in I}\in \sem{M_1\ppp A M_2}}
    {\cmd{}E{\lambda_i}{x_i}{E_i}{i\in I}\in \sem{M_j}
    & j\in\{1,2\}}
    \\\\
    \infer[\mathsf{(Par_2)}]
    {\cmd aE{\lambda_i}{x_i}{E_i}{i\in I}\in \sem{M_1\ppp A M_2}}
    {\cmd aE{\lambda_i}{x_i}{E_i}{i\in I}\in \sem{M_j}
    & a\not\in A    & j\in\{1,2\}}
    \\\\
    \infer[\mathsf{(Par_3)}]
    {
    [] E\land E' \rightarrow \{\lambda_i * \lambda_j': x_i = E_i \land y_j = E_j' \}_{i\in I, j\in J}
    \in \sem{M_1\ppp A M_2}
    }
    {\cmd aE{\lambda_i}{x_i}{E_i}{i\in I}\in \sem{M_1}{}
    & \cmd a{E'}{\lambda_j'}{y_j}{E_j'}{j\in J}\in \sem{M_2}{}
    & a\in A}
    \\\\
    \infer[\mathsf{(Hide_1)}]
    {
    \cmd {}E{\lambda_j}{x_i}{E_i}{i\in I}\in \sem{M/A}{}
    }
    {
    \cmd {}E{\lambda_j}{x_i}{E_i}{i\in I}\in \sem{M}{}
    }
    \qquad
    \infer[\mathsf{(Hide_2)}]
    {
    \cmd {a}E{\lambda_j}{x_i}{E_i}{i\in I}\in \sem{M/A}{}
    }
    {
    \cmd {a}E{\lambda_j}{x_i}{E_i}{i\in I}\in \sem{M}{}
    & a\not\in A
      }
    \\\\
    \infer[\mathsf{(Hide_3)}]
    {
    \cmd {}E{\lambda_j}{x_i}{E_i}{i\in I}\in \sem{M/A}{}
    }
    {
    \cmd {a}E{\lambda_j}{x_i}{E_i}{i\in I}\in \sem{M}{}
    & a\in A
      }
      \qquad
      \infer[\mathsf{(Subst_1)}]
      {
      \cmd {}E{\lambda_j}{x_i}{E_i}{i\in I}\in \sem{\sigma M}{}
      }
      {
      \cmd {}E{\lambda_j}{x_i}{E_i}{i\in I}\in \sem{M}{}
      }
    \\\\
    \infer[\mathsf{(Subst_2)}]
    {
    \cmd {a}E{\lambda_j}{x_i}{E_i}{i\in I}\in \sem{\sigma M}{}
    }
    {
    \cmd {a}E{\lambda_j}{x_i}{E_i}{i\in I}\in \sem{M}{}
    & a\not\in\mathsf{dom}(\sigma)
      }
    \\\\
    \infer[\mathsf{(Subst_3)}]
    {
    \cmd {\sigma a}E{\lambda_j}{x_i}{E_i}{i\in I}\in \sem{\sigma M}{}
    }
    {
    \cmd {a}E{\lambda_j}{x_i}{E_i}{i\in I}\in \sem{M}{}
    & a\in\mathsf{dom}(\sigma)
      }
  \end{array}
\end{displaymath}
The rules above work with modules, parallel composition, name hiding,
and substitution. The idea is that given a network, we wish to collect
all those commands $F$ that are contained in the network,
independently from which module they are being executed
in. Intuitively, we can regard $\sem{N}$ as a set, where starting from
all commands present in the syntax, we do some filtering and renaming,
based on the structure of the network.

Now, given $\sem N$, we define a transition system that shows how the
system evolves.  Let $\state$ be a function that given a variable in
$\mathsf{Var}$ returns a value in $\mathsf{Val}$. Then, given an
initial state $\state_0$, we can define a transition system where each
of node is a (different) $\state$ function. Then, we can move from
$\state_1$ to $\state_2$ whenever ... Formally, a transition system is
defined as:
\begin{definition}[Transition System] 
  [put definition of transition system here. ]
\end{definition}
We can then define a transition system
$\mathcal T = (2^\state,\state_0,\ldots)$ [fix details here].

% That means that once we have a set of executable rules, we can start
% building a transition system. In order to do so, we

% No idea what this stuff below is. 
% \begin{displaymath}
%   \begin{array}{lll}
%     W(M) = \{F \mid F\in\sem{M}\}
%     \\\\
%     X = \{x_1,\ldots,x_n\}
%     \\\\
%     \sigma : X \rightarrow V
%   \end{array}
% \end{displaymath}




\newpage


\subsection{Choreographies}

\mypar{Syntax.} Our choreographic language is defined by the following
syntax:
%
\begin{displaymath}
  \begin{array}{lll}
    \text{(Chor)}
    \quad & C \ ::=\
    &
      \interact{p}{\role p_1,\ldots,\role p_n}
      \ \mid\
      \ifTE {E}{p}{C_1}{C_2}
      \ \mid\
      X
      \ \mid\
      \CEnd
  \end{array}
\end{displaymath}
We comment the various constructs. The syntactic category $C$ denotes
choreographic programmes. The term
$\role p\rightarrow \{\role p_1,\ldots,\role p_n\}\,\Sigma\{\lambda_j:
x_j=E_j;\ C_j\}_{j\in J}$ denotes an interaction initiated by role
$\role p$ with roles $\role p_i$. Unlike in PRISM, a choreography
specifies what interaction must be executed next, shifting the focus
from what can happen to what must happen. When the synchronisation
happens then, in a probabilistic way, one of the branches is selected
as a continuation. The term
$\textsf{if } E@\role p \textsf{ then } C_1 \textsf{
  else } C_2$ factors in some local choices for some particular
roles. [write a bit more about procedure calls, recursion and the zero
process]


\subsection{Projection from Choreographies to PRISM}
\mypar{Mapping Choreographies to PRISM.} We need to run some standard
static checks because, since there is branching, some terms may not be
projectable.
%
\begin{displaymath}
  \begin{array}{lllll}
    \big(q\in\{\role p, \role p_1,\ldots,\role p_n\}, J=\{1,2\},\ l_1, l_2 \text{ fresh}  
\big)\\
    \proj (q,\interact{p}{\role p_1,\ldots,\role p_n}, s)= \\
    \qquad\{ 
    \commandBase {l_1} {s_{\role p_1} = s} {\lambda_1: s_{\role p_1} = s_{\role p_1} +1},\  
    \commandBase {l_2} {s_{\role p_1} = s} {\lambda_2: s_{\role p_1} = s_{\role p_1} +2}  
    \}
    \quad\cup\\
    \qquad \proj (\role{p}_1, C_1, s+1)
    \quad\cup\quad
    \proj (\role{p}_1, C_2, s+\mathsf{nodes}(C_1))
    \\\\
    \big(q\notin\{\role p, \role p_1,\ldots,\role p_n\}\big)\\
    \proj (q,\interact{p}{\role p_1,\ldots,\role p_n}, s)\ = \ \proj (\role{p}_1, C_1, s)
    \ \cup\
    \proj (\role{p}_1, C_2, s+\mathsf{nodes}(C_1))
    \\\\
    \big(q = \role p\big)\\
    \proj (q,\ifTE {E}{p}{C_1}{C_2}, s)= \\
    \qquad\{ 
    \command {} {s_{\role p_1} = s \& E} \lambda: s_{\role p_1} = s_{\role p_1} +1,  
    \command {} {s_{\role p_1} = s \& \mathsf{not}(E)} \lambda: s_{\role p_1} = s_{\role p_1} +1  
    \}
    \quad\cup\\
    \qquad \proj (\role{p}_1, C_1, s+1)
    \quad\cup\quad
    \proj (\role{p}_1, C_2, s+\mathsf{nodes}(C_1))
  \end{array}
\end{displaymath}


       


% proj (p2, p -> {p1} [ lambda1: (x  = 4). C1   +_l   lambda2: (x  = 4123). C2 ], s) = 
%      proj (p2, C1, s+1)
%      \union
%      proj (p2, C2, s+1)




% proj (p, if E@p then C1 else C2, s) = 
%      {
%       [] s_p = s & E s_p = s_p+1, 
%       [] s_p = s & E s_p = s_p+length(C1)
%       }   

% \begin{displaymath}
%   \begin{array}{ll}
%     f\Big(\; \role p_1\longrightarrow\{\role
%     p_i\}_{i\in I} +\{\lambda_j : x_j=E_j: C_j\}_{j\in J}, \texttt{network}, \overline{s}
%     \Big)
%     \\\\
%     =
%     \\\\
%     \ell \text{ fresh};\\
%     %\textsf{label} = \texttt{newlabel}();\\
%     \textsf{for } \role p_k \in \mathbf{roles} \{\\
%     \quad\textsf{for } j \in J \{\\
%     \quad\quad \texttt{network} = \texttt{add}(\role p_k,[\ell]\; {s_{\role p_k} = s_k}
%     \rightarrow\ \Sigma_j\lambda_j : x_j=E_j\;\& \;s_{\role p_k}'=s_k+1);\\
%   	\quad\}\\
%   	\}\\
% 	\textsf{for } j \in J \{\\
% 	\quad \texttt{network} = f(C_j, \texttt{network}, \overline{s}');  \\ 
% 	\}\\
%   	\textsf{return } \texttt{network}
%   \end{array}
% \end{displaymath}




\begin{comment}
\begin{displaymath}
  \begin{array}{ll}
    f\Big(\quad \role p_1\longrightarrow\{\role p_2\} \oplus
    \left\{
    \begin{array}{l}{}
      [\lambda_1] x=5:  \role p_1\longrightarrow\{\role p_2\} \oplus\{[\lambda_3] y=5\}
      \\{}
      [\lambda_2] y=10: \role p_1\longrightarrow\{\role p_2\} \oplus\{[\lambda_4] x=10\}
    \end{array}
    \right\}
    , \ \role p_1:\emptyset\ \pp\ \role p_2:\emptyset
    \Big)
    \\\\
    =
    \\\\
    \text{label} = \text{newlabel}();\\
    \text{for } \role p_i \{\\
    \ add(p_i, [\text{label}] {s_{p_i} = state(p_i)} \rightarrow\
    \left\{
    \begin{array}{ll}
      \lambda_1: x'=5; \textsf{state}(\role p_i)' = \textsf{generatenewstate} (\role p_i)
      \\
      \lambda_2: y'=10; \textsf{state}(\role p_i)' = \textsf{generatenewstate} (\role p_i)
    \end{array}
    \right\}
    \\

    \ f(\role p_1\longrightarrow\{\role p_2\} \oplus\{[\lambda_3] y=5\}, network') = network''\\
    \ return f(\role p_1\longrightarrow\{\role p_2\} \oplus\{[\lambda_4] x=10\}, network'')
    
  \end{array}
\end{displaymath}

\hrule
\end{comment}

% \begin{displaymath}
% 	f : C\times\texttt{network}\times States \longrightarrow \texttt{network} \quad\quad \texttt{network} : \mathcal R \longrightarrow \text{Set}(F)
% \end{displaymath}

% \begin{displaymath}
%   \begin{array}{ll}
%     f\Big(\; \role p_1\longrightarrow\{\role
%  p_i\}_{i\in I} +\{\lambda_j : x_j=E_j: C_j\}_{j\in J}, \texttt{network}, \overline{s}
%     \Big)
%     \\\\
%     =
%     \\\\
%     \ell \text{ fresh};\\
%     %\textsf{label} = \texttt{newlabel}();\\
%     \textsf{for } \role p_k \in \mathbf{roles} \{\\
%     \quad\textsf{for } j \in J \{\\
%     \quad\quad \texttt{network} = \texttt{add}(\role p_k,[\ell]\; {s_{\role p_k} = s_k}
%     \rightarrow\ \Sigma_j\lambda_j : x_j=E_j\;\& \;s_{\role p_k}'=s_k+1);\\
%   	\quad\}\\
%   	\}\\
% 	\textsf{for } j \in J \{\\
% 	\quad \texttt{network} = f(C_j, \texttt{network}, \overline{s}');  \\ 
% 	\}\\
%   	\textsf{return } \texttt{network}
%   \end{array}
% \end{displaymath}

% where $\overline{s} = (s_1, \ldots, s_n)$ and $\overline{s}' = (s_1+1, \ldots, s_n+1)$ for $n = |\mathbf{roles}|$.
% \begin{displaymath}
%   \begin{array}{ll}
%     f\Big(\; \textsf{if } E @ \role p \textsf{ then } C_1 \textsf{ else } C_2, \texttt{network}, \overline{s} 
%     \Big)
%     \\\\
%     =
%     \\\\
%     \textsf{for } \role p_k \in \mathbf{roles} \{\\
%     \quad\texttt{network} = \texttt{add}(\role p_k,[\;]\; s_{\role p_k} = s_k \;\& \;f(E))+f(C_1, \texttt{network},\overline{s});\\
%     \quad\texttt{network} = \texttt{add}(\role p_k,[\;]\; s_{\role p_k} = s_k \;\& \;!f(E))+f(C_1, \texttt{network},\overline{s});\\
%   \}\\
%   \text{return } \texttt {network}\\

%   \end{array}
% \end{displaymath}



%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "main"
%%% End:
