In the previous sections, we have shown our proposed language via an
example. We now formalise the choreographic language by giving its
syntax and semantics.

\mypar{Syntax.} 
%
Let $\role p$ range over a (possibly infinite) set of module names
$\mathcal R$, $a$ over a (possibly infinite) set of labels
$\mathcal L$, $x$ over a (possibly infinite) set of variables
$\Var$, and $v$ over a (possibly infinite) set of values
$\Val$.
%
Choreographies, the key component of our language, are defined by the
following syntax:
%
\begin{displaymath}\small
  \begin{array}{llllllllllll}
    C \ & ::= & \
      \interact{p}{\role p_1,\ldots,\role p_n}
      \ \mid\
      \ifTE {E}{p}{C_1}{C_2}
      \ \mid\ X \ \mid\  \CEnd
    \\[1mm]
    u     & ::=  &       (x' = E) \quad\mid\quad  u\ \&\ u 
    \qquad\qquad\qquad\qquad
    E, g     ::=        f(\tilde E)\quad\mid\quad x\quad\mid\quad v

  \end{array}
\end{displaymath}
% We comment the various constructs. 
The syntactic category $C$ denotes choreographic programs. The
interaction term
$\role p\rightarrow \{\role p_1,\ldots,\role p_n\}\,\Sigma\{\lambda_j:
x_j=E_j;\ C_j\}_{j\in J}$ denotes an interaction initiated by role
$\role p$ with roles $\role p_i$. A choreography specifies what
interaction must be executed next, shifting the focus from what can
happen to what must happen. When the interaction happens, one of the
$i$ branches is selected as a continuation. Branching a random move:
the number $\lambda_i\in\mathbb R$ denotes either a probability or a
rate. This will depend on the language we wish to use. In the case of
probabilities, it must be the case that $0\leq\lambda_i\leq 1$ and
$\Sigma_i\lambda_i=1$. Once a branch is taken, the choreography will
execute some assignments $u_i$. A single assignment has the syntax
$(x' = E)$ meaning that the value obtained by evaluating expression
$E$ is assigned to variable $x$. Note that $x'$ is used for an
assignment to $x$: here, we follow the syntax adopted in PRISM
(see~\S~\ref{sec:prism}). Expressions are obtained by applying some
unspecified functions to other expressions. Their base term are
variables and values (denoted by $v$).
%

The term
$\textsf{if } E@\role p \textsf{ then } C_1 \textsf{ else } C_2$
denotes a system where role $\role p$ evaluated the guard $E$ (which
can contain variables located at other roles) and then branches
accordingly.  The term $X$ is a procedure call: in the semantics, we
will have an extra environment where such procedure names are
defined. Such calls can be used for recursion. The term $\CEnd$
denotes the system finishing its computation.

\bigskip


\mypar{Semantics.} In the sequel, we define a state, denoted by $S$,
as a mapping from variables to values, i.e.,
$S: \Var \rightarrow\Val$. Then, given a value $v$ and a variable $x$,
a substitution $[v/x]$ is an update on a state, i.e.,
$\small S[v/x] (y)= \left\{
  \begin{array}{ll} 
    v    & \text{ if } y=x\\ 
    S(y) & \text{ otherwise}
  \end{array} \right.
$

Then, given the set of all possible states $\mathcal S$ and a set of
definitions $\Sigma$ of the form $X\stackrel{\mathsf{def}}{=} C$, we
can define the operational semantics of choreographies as the minimal
relation relation
$\red{}\subseteq \mathcal S\times C\times \mathcal R\times \mathcal
S\times C$ such that:
\begin{displaymath}\small
  \begin{array}{l@{\quad}llll}
    \textsf{(Interact)} &
    (S, \interact{p}{\role p_1,\ldots,\role p_n}) 
    \red{\lambda_j}
    (S[S(E_j)/x_j], C_j) 
    \\[1mm]
    \textsf{(IfThenElseT)} &
    S(E) = \mathsf{tt} \quad\Rightarrow\quad
    (S,\ifTE {E}{p}{C_1}{C_2}) 
    \red{1}
    (S, C_1)
    \\[1mm]
    \textsf{(IfThenElseF)} &
    S(E) = \mathsf{ff} \quad\Rightarrow\quad
    (S,\ifTE {E}{p}{C_1}{C_2}) 
    \red{1}
    (S, C_2)
    \\[1mm]
    \textsf{(Call)} &
    X\stackrel{\mathsf{def}}{=} C\in\Sigma \quad\Rightarrow\quad (S, X) \red{1}(S,C)
  \end{array}
\end{displaymath}
Above, $S(E_j)$ and $S(E)$ are unspecified (decidable) evaluations of
the expression $E$ under state $S$. The transition relation is a
Discrete Time Markov Chain (DTMC) or a Continuous Time Markov Chain
(CTMC) depending on whether we use probabilities or rates in the
branching construct~\cite{ctmc}. States of the Markov chain are the
pairs $(S,C)$.
%

Below, we look at two corner-case examples.
\begin{example}
  Consider the following definition:
  \begin{displaymath}
    \begin{array}{lll}
      C \ {=}\ \interactBase{p}{q}\ \lambda_1: (x'=1);\quad \interactBase{p}{q}\ \lambda_1: (x'=1);\CEnd
    \end{array}
  \end{displaymath}
  The semantics of $C$ starting from a state in which $S(x)=S(y)=0$
  can be depicted as follows (for
  $C'= \interactBase{p}{q}\ \lambda_1: (x'=1);\CEnd$):

\bigskip

\begin{tikzpicture}\small
    \node[state, initial] (1) 
    {\tiny$\begin{array}{c}
      C \\ x=0
    \end{array}$};
    \node[state, right of=1, xshift=3cm] (2) 
        {\tiny$\begin{array}{c}
      C' \\ x=1
    \end{array}$};
    \node[state, right of=2, xshift=3cm] (3) 
        {\tiny$\begin{array}{c}
      \CEnd \\ x=1
    \end{array}$};
     \draw   (1) edge[above] node{$\lambda_1$} (2)
             (2) edge[below] node{$\lambda_2$} (3)
     ;
\end{tikzpicture}
\end{example}


\begin{example}
  Consider the following definition:
  \begin{displaymath}
    \begin{array}{lll}
      C \stackrel{\mathsf{def}}{=} \interactBase{p}{q}
      \left\{
      \begin{array}{lll}
        42: (x'=1)\&(y'=2);\ C
        \\
        404: (x'=3)\&(y'=1);\ C
      \end{array}
      \right.
    \end{array}
  \end{displaymath}
The semantics of $C$ starting from a state in which $S(x)=S(y)=0$ can
be depicted as follows:

\bigskip

\begin{tikzpicture}\small
    \node[state, initial] (1) 
    {\tiny$\begin{array}{c}
      C \\ x=0\\ y=0
    \end{array}$};
    \node[state, right of=1, xshift=4cm] (2) 
        {\tiny$\begin{array}{c}
      C \\ x=1\\ y=2
    \end{array}$};
    \node[state, below right of=1, xshift=1.8cm] (3) 
        {\tiny$\begin{array}{c}
      C \\ x=3\\ y=1
    \end{array}$};
     \draw   (1) edge[above, bend left] node{$\lambda_1$} (2)
             (1) edge[below, bend right] node{$\lambda_2$} (3)
             (2) edge[loop right] node{$\lambda_1$} (2)
             (3) edge[loop below] node{$\lambda_2$} (3)
             (2) edge[below, bend left] node{$\lambda_2$} (3)
             (3) edge[above] node{$\lambda_1$} (2)
     ;
\end{tikzpicture}
\end{example}

%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "main"
%%% End:
