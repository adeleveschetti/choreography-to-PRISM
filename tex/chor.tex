In the previous section, we have shown our proposed language via an
example. We now formalise the choreographic language by giving its
syntax and semantics.

\mypar{Syntax.} 
%
Let $\role p$ range over a (possibly infinite) set of module names
$\mathcal R$, $a$ over a (possibly infinite) set of labels
$\mathcal L$, $x$ over a (possibly infinite) set of variables
$\Var$, and $v$ over a (possibly infinite) set of values
$\Val$.
%
Choreographies, the key component of our language, are defined by the
following syntax:
%
\begin{displaymath}\small
  \begin{array}{llllllllllll}
    C \ & ::= & \
      \interact{p}{\role p_1,\ldots,\role p_n}
      \ \mid\
      \ifTE {E}{p}{C_1}{C_2}
      \ \mid\ X \ \mid\  \CEnd
    \\[1mm]
    u     & ::=  & (x' = E)\ \&\ u \quad\mid\quad    (x' = E)
    \qquad\qquad\qquad
    E, g     ::=        f(\tilde E)\quad\mid\quad x\quad\mid\quad v

  \end{array}
\end{displaymath}

% We comment the various constructs. 
The syntactic category $C$ denotes choreographic programs. The
interaction term
$\role p\rightarrow \{\role p_1,\ldots,\role p_n\}:\,\Sigma\{\lambda_j:
x_j=E_j.\ C_j\}_{j\in J}$ denotes an interaction initiated by role
$\role p$ with roles $\role p_i$. A choreography specifies what
interaction must be executed next, shifting the focus from what can
happen to what must happen. When the interaction happens, one of the
$i$ branches is selected as a continuation. Branching a random move:
the number $\lambda_i\in\mathbb R$ denotes either a probability or a
rate. This will depend on the language we wish to use. In the case of
probabilities, it must be the case that $0\leq\lambda_i\leq 1$ and
$\Sigma_i\lambda_i=1$. Once a branch is taken, the choreography will
execute some assignments $u_i$. A single assignment has the syntax
$(x' = E)$ meaning that the value obtained by evaluating expression
$E$ is assigned to variable $x$. Note that $x'$ is used for an
assignment to $x$: here, we follow the syntax adopted in PRISM
(see~\S~\ref{sec:prism}). Expressions are obtained by applying some
unspecified functions to other expressions. Their base term are
variables and values (denoted by $v$).
%

The term
$\textsf{if } E@\role p \textsf{ then } C_1 \textsf{ else } C_2$
denotes a system where role $\role p$ evaluated the guard $E$ (which
can contain variables located at other roles) and then branches
accordingly.  The term $X$ is a procedure call: in the semantics, we
will have an extra environment where such procedure names are
defined. Such calls can be used for recursion. The term $\CEnd$
denotes the system finishing its computation.

\bigskip


\mypar{Semantics.} In the sequel, we define a state, denoted by $S$,
as a mapping from variables to values, i.e.,
$S: \Var \rightarrow\Val$. Given a value $v$ and a variable $x$, a
substitution $[v/x]$ is an update on a state, i.e.,
$\small S[v/x] (y)= \left\{
  \begin{array}{ll} 
    v    & \text{ if } y=x\\ 
    S(y) & \text{ otherwise}
  \end{array} \right.
$
%
Then, the update $S[u]$ is such that
$S[x'=E\ \&\ u] = S[\eval ES/x][u]$ and $S[x'=E] = S[\eval ES/x]$,
where $\eval ES$ is an unspecified (decidable) evaluations of the
expression $E$ in the state $S$.

Given the set of all possible states $\mathcal S$ and a set of
definitions $\Sigma$ of the form $X\stackrel{\mathsf{def}}{=} C$, we
can define the operational semantics of choreographies as the minimal
relation relation
$\red{}\subseteq \mathcal S\times C\times \mathcal R\times \mathcal
S\times C$ such that:
\begin{displaymath}\small
  \begin{array}{l@{\quad}llll}
    \textsf{(Interact)} &
    (S, \interact{p}{\role p_1,\ldots,\role p_n}) 
    % \red{\Sigma_{(S[u_j],C_j)=(S',C')}\lambda_j}
    % (S', C') 
    \red{\lambda_j}
    (S[u_j], C_j) 
    \\[1mm]
    \textsf{(IfThenElseT)} &
    \eval ES = \mathsf{tt} \quad\Rightarrow\quad
    (S,\ifTE {E}{p}{C_1}{C_2}) 
    \red{1}
    (S, C_1)
    \\[1mm]
    \textsf{(IfThenElseF)} &
    \eval ES = \mathsf{ff} \quad\Rightarrow\quad
    (S,\ifTE {E}{p}{C_1}{C_2}) 
    \red{1}
    (S, C_2)
    \\[1mm]
    \textsf{(Call)} &
    X\stackrel{\mathsf{def}}{=} C\in\Sigma \quad\Rightarrow\quad (S, X) \red{1}(S,C)
  \end{array}
\end{displaymath}
The transition relation is a Discrete Time Markov Chain (DTMC) or a
Continuous Time Markov Chain (CTMC) depending on whether we use
probabilities or rates in the branching construct~\cite{ctmc}. States
of the Markov chain are the pairs $(S,C)$. Transitions are given by
the relation $\red{}$.
%

Below, we look at two corner-case examples.
\begin{example}
  Consider the following definition:
  \begin{displaymath}
    \begin{array}{lll}
      C \ {=}\ \interactBase{p}{q}\ \lambda_1: (x'=1);\quad \interactBase{p}{q}\ \lambda_2: (x'=1);\CEnd
    \end{array}
  \end{displaymath}
  The semantics of $C$ starting from a state in which $S(x)=S(y)=0$
  can be depicted as follows (for
  $C'= \interactBase{p}{q}\ \lambda_1: (x'=1);\CEnd$):

\bigskip

\begin{tikzpicture}\small
    \node[state, initial] (1) 
    {\tiny$\begin{array}{c}
      C \\ x=0
    \end{array}$};
    \node[state, right of=1, xshift=3cm] (2) 
        {\tiny$\begin{array}{c}
      C' \\ x=1
    \end{array}$};
    \node[state, right of=2, xshift=3cm] (3) 
        {\tiny$\begin{array}{c}
      \CEnd \\ x=1
    \end{array}$};
     \draw[->]   (1) edge[above] node{$\lambda_1$} (2)
             (2) edge[below] node{$\lambda_2$} (3)
     ;
\end{tikzpicture}
\end{example}

% \AV{Ho sistemato le frecce e i $\lambda$ (prima erano due $\lambda_1$ nell'esempio 1). Nell'esempio 2 non c'erano $\lambda$ nella definizione  }
\begin{example}
  Consider the following definition:
  \begin{displaymath}
    \begin{array}{lll}
      C \stackrel{\mathsf{def}}{=} \interactBase{p}{q}
      \left\{
      \begin{array}{lll}
        \lambda_1: (x'=1)\&(y'=2);\ C
        \\
        \lambda_2: (x'=3)\&(y'=1);\ C
      \end{array}
      \right.
    \end{array}
  \end{displaymath}
The semantics of $C$ starting from a state in which $S(x)=S(y)=0$ can
be depicted as follows:

\bigskip

\begin{tikzpicture}\small
    \node[state, initial] (1) 
    {\tiny$\begin{array}{c}
      C \\ x=0\\ y=0
    \end{array}$};
    \node[state, right of=1, xshift=4cm] (2) 
        {\tiny$\begin{array}{c}
      C \\ x=1\\ y=2
    \end{array}$};
    \node[state, below right of=1, xshift=1.8cm] (3) 
        {\tiny$\begin{array}{c}
      C \\ x=3\\ y=1
    \end{array}$};
     \draw [->]  (1) edge[above, bend left] node{$\lambda_1$} (2)
             (1) edge[below, bend right] node{$\lambda_2$} (3)
             (2) edge[loop right] node{$\lambda_1$} (2)
             (3) edge[loop below] node{$\lambda_2$} (3)
             (2) edge[below, bend left] node{$\lambda_2$} (3)
             (3) edge[above] node{$\lambda_1$} (2)
     ;
\end{tikzpicture}
\end{example}

%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "main"
%%% End:
