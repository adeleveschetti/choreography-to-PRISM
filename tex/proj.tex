Our next task is to provide a mapping that can translate
choreographies into the PRISM language. The goal of this section is to
address the theoretical aspect of this.

\mypar{Mapping Choreographies to PRISM.}  The operation of generating
endpoint code from a choreography is known as {\em
  projection}. Normally, projection is defined separately for each
module appearing in the choreography program. We first observe that in
order to simulate interactions in PRISM, we need to use labels on
which each module in the interaction can synchronise. Therefore,
without loss of generality, we make a slight abuse of notation and
assume that each step in a choreography is annotated with unique
labels that then it is going to be used by the projection. We call
such a choreography a {\em well-annotated choreography}. For example,
the choreography
$\interactBase{p}{q}\ \lambda_1: \CEnd \ +\ \lambda_2: \ifTE
  {E}{p}{\CEnd}{\CEnd}$ is going to be annotated as
  $\interactBasel{p}{a_1}{q}\ \lambda_1: \CEnd \ +\ \lambda_2: \ifTEl
    {E}{a_2}{p}{\CEnd}{\CEnd}$.


%
    \MC{We need to say that we must run some standard static checks
      because, since there is branching, some terms may not be
      projectable.}
%

    We can now formally define the projection of a choreography with
    rates into the PRISM language.
    % 
    \begin{definition}[Projection, CTMC]\label{def:projCTMC} Given a
      well-annotated choreography $C$ with
      rates, a module $\role p$, and a natural number $\iota$, we
      define the projection function $\proj$ as:
      \begin{displaymath}\small
        \begin{array}{lr}

          \proj (\role q,\interact{p}{\role p_1,\ldots,\role p_n}, \iota)= 
          &  \boxed{\text{if }\role q=\role p}\\[2mm]
          \qquad
          % \{ 
          \Big\{\commandBase {l_j} {\ s_{q}\!=\! \iota} {\lambda_j:\ s_{q}\!=\!
          s_{q} +1+\sum_{k=1}^{j-1}\mathsf{nodes}({C_k})}\ \&\ \projE
          {E_j}q\Big\}_{j\in J}
          \\
          \qquad\cup\ \bigcup_{j} \proj (\role q, C_j, s+1+\sum_{k=1}^{j-1}\mathsf{nodes}({C_k}))
          \\\\

          \proj (\role q,\interact{p}{\role p_1,\ldots,\role p_n}, \iota)= 
          &  \!\!\!\!\!\! \!\!\!\!\!\!\boxed{\text{if }\role q\in\{\role p_1,\ldots,\role p_n\}}\\[2mm]
          \qquad
          % \{ 
          \Big\{\commandBase {l_j} {\ s_{q}\!=\! \iota} {1:\ s_{q}\!=\!
          s_{q} +1+\sum_{k=1}^{j-1}\mathsf{nodes}({C_k})}\ \&\ \projE
          {E_j}q\Big\}_{j\in J}
          \\
          \qquad\cup\ \bigcup_{j} \proj (\role q, C_j, s+1+\sum_{k=1}^{j-1}\mathsf{nodes}({C_k}))
          \\\\

          \proj (\role q,\interact{p}{\role p_1,\ldots,\role p_n}, \iota)= 
          &  \!\!\!\!\!\! \!\!\!\!\!\!\boxed{\text{if }\role q\not\in\{\role p, 
            \role p_1,\ldots,\role p_n\}}\\[2mm]
          \qquad\ \proj (\role{q}, C_1, s)=
          \ \cup\
          \proj (\role{q}, C_2, s+\mathsf{nodes}(C_1))
          \\\\

          \proj (\role q,\ifTE {E}{p}{C_1}{C_2}, \iota) = 
          &  \boxed{\text{if }\role q=\role p}\\[2mm]
          \qquad\left\{ 
          \begin{array}{lll}
            \commandBase {} {s_{q}\!=\! \iota\ \&\ E}{\ 1: s'_{q}\!=\! \iota+1},\\ 
            \commandBase {} {s_{q}\!=\! \iota\ \&\ \mathsf{not}(E)}
            {\ 1: s'_{q}\!=\! \iota+\mathsf{nodes}(C_1)+1}
          \end{array}
          \right\}
          \\
          \qquad\cup\quad \proj (\role{p}, C_1, \iota+1)
          \quad\cup\quad
          \proj (\role{p}, C_2, \iota+\mathsf{nodes}(C_1)+1)
          \\\\

          \proj (\role q,\ifTE {E}{p}{C_1}{C_2}, \iota) = 
          &  \boxed{\text{if }\role q\neq\role p}\\[2mm]
          \qquad\proj (\role{q}, C_1, \iota+1)
          \quad\cup\quad
          \proj (\role{q}, C_2, \iota+\mathsf{nodes}(C_1)+1)

          \\\\

          \proj (\role q,\CEnd, \iota) = \emptyset

        \end{array}
      \end{displaymath}
    \end{definition}
    We go through the various cases of the definition above. The first
    three cases handle the projection of an interaction. If we project
    the first module $\role p$, then we create one command per branch,
    assigning the corresponding rate. Note that this is possible since
    we are dealing with rates. The additional variable $s_{\role q}$
    is the counter for this module and we identify uniquely this
    interaction. In order to do it consistently for follow up
    statements of the subterm choreographies, we use the function
    $\mathsf{nodes}(C)$ which returns the number of nodes of $C$,
    i.e., the number of steps of the projection function. Obviously,
    when projecting the next branch we need to take into account all
    other possible branches that may have been already projected. For
    the sake of space, we do not define the function precisely, but we
    observe that this could also be easily defined via the label
    annotations. The second case defines the projection of an
    interaction when we are projecting one of the roles in
    $\{\role p_1,\ldots,\role p_n\}$. Similarly to the previous case,
    we define a command for each branch of the interaction. However,
    the rate of each command is going to be $1$. The if-then-else
    construct is only interesting for module $\role p$: in this case,
    the module makes an internal choice based on the evaluation of the
    guard $E$. The other modules will be projected according to
    choreographies $C_1$ and $C_2$.

    As hinted above, the projection in Definition~\ref{def:projCTMC}
    would be incorrect if instead of using rates we used
    probabilities. This is simply because we cannot force both
    $\role p$ and $\{\role p_1,\ldots,\role p_n\}$ with the
    distribution imposed by the $\lambda_i$'s. In order to fix this
    problem, we have the following definition instead:
    % 
    \begin{definition}[Projection, DTMC]\label{def:projDTMC} Given a well-annotated
      choreography $C$ with probabilities, a module $\role p$, and a
      natural number $\iota$, we define the projection function
      $\proj$ as:
      \begin{displaymath}\small
        \begin{array}{lr}

          \proj (\role q,\interact{p}{\role p_1,\ldots,\role p_n}, \iota)= 
          &  \boxed{\text{if }\role q=\role p}\\[2mm]
          \qquad
          \left\{
          \begin{array}{lll}
            \commandBase {} {s_{q}\!=\! \iota}{\ \sum_{j\in J} \lambda_j: s'_{q}\!=\! \iota+1+j},\\ 
            \{\commandBase {l_j} {s_{q}\!=\! \iota+1+j}
            \ 1: s'_{q}\!=\! \iota+1+\sum_{k=1}^{j-1}\mathsf{nodes}({C_k})\ \&\ \projE
            {E_j}q\}_{j\in J}
          \end{array}
          \right\}
          \\
          \qquad\cup\ \bigcup_{j} \proj (\role q, C_j, s+1+\sum_{k=1}^{j-1}\mathsf{nodes}({C_k}))
          \\\\

        \end{array}
      \end{displaymath}
      For the other cases, the definitions are equivalent to the one
      presented in Definition \ref{def:projCTMC}.
    \end{definition}
    The fix is immediate: module $\role p$ takes a (probabilistic)
    internal decision on the $j^{\text{th}}$ branch and then
    synchronises on label $l_j$ with $\{\role p_1,\ldots,\role p_n\}$.       


    \mypar{Correctness.} We now show that our projection operations
    are correct with respect to the semantics of choreographies and
    PRISM. In the sequel, $S_+$ is a state $S$ extended with extra
    variables used by the projection. Moreover, we say that a
    choreography is {\em well-formed} if the behaviour in each
    branching for modules who do not participate to the interaction is
    identical.
      \begin{theorem}[EPP]\label{thm:epp}
        Given a well-formed choreography $C$, we have that
        $(S,C) \red{\lambda} (S', C')$ iff
        $\proj (*, C)\vdash S\uplus S_{+}\red{\lambda} S'\uplus S_{+}'$.
      \end{theorem} 
      \begin{proof} We need to build an argument for rates and
        probabilities separately. Let us focus on the projection in
        Definition~\ref{def:projCTMC} first. The proof proceeds by
        induction on the term $C$. For
        $C=\interact{p}{\role p_1,\ldots,\role p_n}$, we clearly have
        that, for any state $S$ there exists $S'$ such that
        $(S,C)\red{\lambda_j}(S',C_j)$. We need to show two things:
        first, that the projection of $C$ can make the same
        transition; second, that if the projection makes a transition,
        it must be corresponding to that of the choreography above.



        \newpage We prove each direction separately.
        \begin{itemize}
        \item (only if). Assume that
          % 
    $$(S, \interact{p}{\role p_1,\ldots,\role
      p_n})\red{\lambda_j}(S[\sigma(E_j)/x_j], C_j)$$
    % 
    and let us consider the projection of the term
    %
    $$\interact{p}{\role p_1,\ldots,\role p_n}$$
    % 
    Given some fresh $l_1,\ldots, l_n$, we generate the following
    commands for each $q$ in
    $\{\role p, \role p_1,\ldots,\role p_n\}$:
    % 
    $$
    \Big\{\commandBase {l_j} {\ s_{q}\!=\! s} {\kappa_j:\ s_{q}\!=\!
      s_{q} +1+\sum_{k=1}^{j-1}\mathsf{nodes}({C_k})}\ \&\ \projE
    {E_j}q\Big\}_{j\in J}
    $$
    %
    where $\kappa_j=\lambda_j$ if $q\neq\role p$ and $\kappa_j=1$
    otherwise. 
    % 
    Because the labels $l_j$ are fresh and the state counter is unique
    to this interaction, these are the only commands that can
    synchronise together: this can be shown from the rules defining
    the semantics of PRISM. Additionally, since all rates are set to 1
    besides the commands generated for role $\role p$, the transition
    will also be labelled with $\lambda_j$.


  \item (if). In the opposite direction, we have that 
    % 
    $$\proj (*, \interact{p}{\role p_1,\ldots,\role p_n})\vdash
    S\uplus S_{+}\red{\lambda} S'\uplus S_{+}'$$
    %
    Again, given some fresh $l_1,\ldots, l_n$, the projection that
    reduces must be such that for each $q$ in
    $\{\role p, \role p_1,\ldots,\role p_n\}$:
    % 
    $$
    \Big\{\commandBase {l_j} {\ s_{q}\!=\! s} {\kappa_j:\ s_{q}\!=\!
      s_{q} +1+\sum_{k=1}^{j-1}\mathsf{nodes}({C_k})}\ \&\ \projE
    {E_j}q\Big\}_{j\in J}
    $$
    %
    where $\kappa_j=\lambda_j$ if $q\neq\role p$ and $\kappa_j=1$
    otherwise. 
    % 
    Again, the freshness of the labels $l_j$ together with the working
    states $s_qq$

    Because the labels $l_j$ are fresh and the state counter is unique
    to this interaction, these are the only commands that can
    synchronise together: this can be shown from the rules defining
    the semantics of PRISM. Additionally, since all rates are set to 1
    besides the commands generated for role $\role p$, the transition
    will also be labelled with $\lambda_j$.

  \end{itemize}
\end{proof}

%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "main"
%%% End:
