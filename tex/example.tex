In particular, by employing choreographies, we gain a clear and comprehensive view of the interactions occurring within the system, allowing us to discern the flow of processes and detect any potential sources of error. This transparency ensures that each step is understood and executed accurately, minimizing the likelihood of errors and enhancing the reliability of the system.

\begin{lstlisting}[style=prism-color,caption={A PRISM example},captionpos=b,label={example1},escapechar=|]
	ctmc 
	module User|\label{user-init}|
		User_STATE : [0..2] init 0;
	
		[alpha_1] (User_STATE=0) $\rightarrow$ lambda : (User_STATE'=1);|\label{first-line}|
		[alpha_2] (User_STATE=0) $\rightarrow$ lambda : (User_STATE'=2);
		[beta] (User_STATE=1) $\rightarrow$ mu : (User_STATE'=0);
		[gamma_1] (User_STATE=2) $\rightarrow$ theta : (User_STATE'=1);
		[gamma_2] (User_STATE=2) $\rightarrow$ theta : (User_STATE'=2);
	endmodule|\label{user-end}|
	
	module CheckOut|\label{check-init}|
		CheckOut_STATE : [0..1] init 0;
	
		[alpha_1,alpha_2] (CheckOut_STATE=0) $\rightarrow$ 1 : (CheckOut_STATE'=1);
		[beta] (CheckOut_STATE=1) $\rightarrow$ 1 : (CheckOut_STATE'=0);
		[gamma_1,gamma_2] (CheckOut_STATE=1) $\rightarrow$ 1 : (CheckOut_STATE'=1);
	endmodule|\label{check-end}|
	\end{lstlisting}

As an example we report in Listing \ref{example1} a simplified version of a model presented in the PRISM documentation\footnote{\url{https://www.prismmodelchecker.org/casestudies/thinkteam.php}}. The model represents a system where users move between different states (0, 1, or 2) based on certain events $(\alpha, \beta, \gamma)$ with corresponding rates $(\lambda, \mu, \theta)$, and there's also a checkout process that transitions between two states (0 or 1).

The modules \codeprism{User} (line \ref{user-init} to \ref{user-end}) and \codeprism{CheckOut} (line \ref{check-init} to \ref{check-end}) synchronize on different actions with labels \codeprism{alpha_1}, \codeprism{alpha_2}, \codeprism{beta}, \codeprism{gamma_1} and \codeprism{gamma_2}. On line \ref{first-line}, \codeprism{(User_STATE=0)} is the condition, indicating that this transition is enabled when \codeprism{User_STATE} has value 0. The variable \codeprism{lambda} represents a rate, since the program models a Continous Time Markov Chain (CTMC). Moreover, the command \codeprism{(User_STATE'=1)} is an update, indicating that \codeprism{User_STATE} changes to 1 when this transition fires.

Understanding the interactions between processes in this example might indeed be challenging, especially without additional context or explanation. 
Alternatively, when formalized using our choreographic language, the same model becomes significantly clearer, as shown in Listing \ref{example2}. 
\begin{lstlisting}[style=chor-color,caption={Example of Listing \ref{example1} in our choreographic language},captionpos=b,label={example2}]
    C0 := User $\rightarrow$ Check : (+["lambda*1"]  " "&&" " . C1							       +["lambda*1"]  " "&&" " .  C2)
    C1 := User $\rightarrow$ Check : (+["beta*1"]  " "&&" " . C0)  
    C2 := User $\rightarrow$ Check : (+["mu*1"]  " "&&" " . C1
                                 +["mu*1"]  " "&&" " .  C2)
\end{lstlisting}
In this model, we define three distinct choreographies, namely \texttt{C0}, \texttt{C1}, and \texttt{C2}. These choreographies describe the interaction patterns between the roles \texttt{User} and \texttt{Check}. The state updates resulting from these interactions are not explicitly depicted as they are automatically generated. Similarly, this consideration extends to the labels used within the model. Just as the state updates are automatically generated, unique labels used to denote various transitions in the model are also automatically assigned.
As evident from the presented example, the choreographic language facilitates a straightforward understanding of the interactions between processes, minimizing the likelihood of errors.



%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "main"
%%% End: