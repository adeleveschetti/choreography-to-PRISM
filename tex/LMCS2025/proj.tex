In this section, we provide a rigorous treatment of projection, which
constitutes the mapping from choreographies to the PRISM language.
%

\subsection{Mapping Choreographies to PRISM} 
%
The process of generating endpoint code from a choreography is
commonly referred to as {\em projection}.  Typically, projection is
defined separately for each module appearing in the choreography
program, i.e., given a module (often called a role) and a
choreography, it generates the code for that particular role.
However, this is not the case in our approach, as PRISM relies solely
on label synchronisation and a notion of state, which can be modified
through standard imperative assignments enabled by conditions on the
state.
%
Thus, our approach simulates a choreography interaction in PRISM by
using (i) labels on which each involved module can synchronise and
(ii) the state to enable the correct commands at the appropriate
time.

Before formalising this idea, we % make a slight abuse of notation by
assume that each interaction in a choreography is annotated with a
label. We refer to such a choreography as an {\em annotated
  choreography}:
%
\begin{definition}[Annotated Choreography]
  An \emph{annotated choreography} is obtained from the choreography
  syntax by adding a label (from $\mathcal L$) to each interaction:
  \[C ::= \interactl{\nr}a{\nr_1,\ldots,\nr_n} \mid\dots\]
\end{definition}
%
The intuition behind annotations is that they allow us to identify a
particular interaction in the choreography, enabling all modules
involved to synchronise. Since these annotations must be unique, we
make the following assumption, which is key to our results:
\begin{assumption}
  Each annotation in an annotated choreography occurs exactly once.
\end{assumption}
% This assumption above ensures that every interaction can be uniquely
% identified and referenced in the corresponding endpoint projection. 
As an example, the following choreography is annotated correctly:
% 
\[
  \interactBasel{\nr}a{\nrr,\nrrr}:
  \left(
    \begin{array}{ll}
      \lambda_1: \ \CEnd \\
      \quad+\\
      \lambda_2:\
      % 
      \ifTE {E}{\nr}{\ \interactBasel{\nr}b{\nrr}: \lambda_1: \CEnd\ }{\CEnd}
    \end{array}
  \right)
\]
  % 
while, the one below is not: 
% 
\[
  \interactBasel{\nr}a{\nrr,\nrrr}:
  \left(
    \begin{array}{ll}
      \lambda_1: \ \CEnd \\
      \quad+\\
      \lambda_2:\
      % 
      \ifTE {E}{\nr}{\ \interactBasel{\nr}a{\nrr}: \lambda_1: \CEnd\ }{\CEnd}
    \end{array}
  \right)
\]
% 

\smallskip

%
In order to ensure consistency for subsequent statements in a
choreography, our definition of projection uses the function
\( \mathsf{nodes}(C) \), which returns the number of nodes in the abstract
syntax tree (AST) of \( C \). Formally, it is defined as:
\begin{displaymath}
  \begin{array}{llll}
    \mathsf{nodes}(\interact{p}{\role p_1,\ldots,\role p_n})\ =\ 1+\sum_{j\in J}\mathsf{nodes}(C_j)\\
    \mathsf{nodes}(\ifTE {E}{p}{C_1}{C_2})\ =\ 1+\mathsf{nodes}(C_1)+\mathsf{nodes}(C_2)\\
    \mathsf{nodes}(X)\ =\ 
    \mathsf{nodes}(\CEnd)\ =\ 1
  \end{array}
\end{displaymath}
% Specifically, it counts the steps (or interaction points) within
% each branch of the choreography. In the context of recursive
% choreographies, it also counts the recursive steps, helping to
% compute how far into the choreography a particular interaction or
% branch has progressed.

Additionally, given a label $a$ and a set of indices $I$, the set $\{a_i|i\in I\}$ contains unique identifiers generated from $a$.

We now define the projection function. Since there are key differences
between using probabilities and using rates, we proceed separately. We
begin with choreographies that involve rates: 
% 
\begin{definition}[Projection, CTMC]\label{def:projCTMC} Given an
  annotated choreography with rates $C$, a module $\nrr$, and
  $J=\{1,\dots,m\}$, we define the function $\proj$ as:
  \begin{displaymath}\small
    \begin{array}{lr}

      \proj (\role q,\interactl{\nr}{a}{\nr_1,\ldots,\nr_n})= 
      &  \boxed{\text{if }\nrr=\nr}\\[2mm]
      \qquad
      % \{ 
      \left\{\commandBase {a_j} {\ s_{\nrr}\!=\! a} {\lambda_j:}
      \ s_{\nrr}'\!=\! \mathsf{top}_{\nrr}(C_j)\ 
      \&\ \projE {u_j}\nrr\right\}_{j\in J}
      \ \quad\cup\ \quad\bigcup_{j\in J} \proj (\nrr, C_j)
      
      \\[1cm]

          
      \proj (\nrr,\interactl{\nr}{a}{\nr_1,\ldots,\nr_n}, \iota)= 
      &  \boxed{\text{if }
        \nrr\in\{\role p_1,\ldots,\role p_n\}}\\[2mm]
      \qquad
      \left\{\commandBase {a_j} {\ s_{\nrr}\!=\! a} {1:\ s_{\nrr}'\!=\!
      \mathsf{top}_{\nrr}(C_j)
      }
      \ \&\ \projE {u_j}\nrr\right\}_{j\in J}
      \ \quad\cup\ \quad \bigcup_{j\in J} \proj (\role q, C_j)
      
      \\[1cm]
      
      \proj (\nrr,\interactl{\nr}a{\nr_1,\ldots,\nr_n})\ =
      \ \bigcup_{j\in J} \proj (\role q, C_j)
      &  \hspace{-1cm}\boxed{\text{if }\role q\not\in\{\role p, 
        \nr_1,\ldots,\nr_n\}}

      \\[1cm]

      \proj (\nrr,\ifTEl {E}a{\nr}{C_1}{C_2}) = 
      &  \boxed{\text{if }\nrr=\nr}\\[2mm]
      \qquad\left\{ 
      \begin{array}{lll}
        \commandBase {} {s_{\nrr}\!=\! a\ \&\ E}{\ 1: s'_{\nrr}\!=\!
        \mathsf{top}_{\nrr}(C_1)},\\ 
        \commandBase {} {s_{\nrr}\!=\! a\ \&\ \mathsf{not}(E)}
        {\ 1: s'_{\nrr}\!=\! \mathsf{top}_{\nrr}(C_2)}
      \end{array}
      \right\}
      \quad\cup\quad \proj (\nrr, C_1)
      \quad\cup\quad
      \proj (\nrr, C_2)
      \\[1cm]

      \proj (\nrr,\ifTEl {E}a{\nr}{C_1}{C_2}) \ =\
      \proj (\nrr, C_1)
      \ \cup\
      \proj (\nrr, C_2)

      &  \boxed{\text{if }\nrr\neq\nr}
      

      \\[1cm]

      \proj (\nrr,\CEnd) = \emptyset

      \qquad\qquad

      \proj (\nrr, X^a) = 
      \{ \commandBase {a} {s_{\nrr}\!=\! a}{\ 1: s'_{\nrr}\!=\! } \mathsf{top}_{\nrr}(C)\}
      &\boxed{X\stackrel{\textcolor{sh_keyword}{\mathsf{def}}}{=} C\in\defin}

        \end{array}
      \end{displaymath}
    \end{definition}
  %   \begin{definition}[Projection, CTMC]\label{def:projCTMC} Given an
  % annotated choreography with rates $C$, a module $\role q$, a natural
  % number $\iota$, and $J=\{1,\dots,m\}$, we define the function
  % $\proj$ as:
  % \begin{displaymath}\small
  %       \begin{array}{lr}

  %         \proj (\role q,\interactl{p}{a}{\role p_1,\ldots,\role p_n}, \iota)= 
  %         &  \boxed{\text{if }\role q=\role p}\\[2mm]
  %         \qquad
  %         % \{ 
  %         \left\{\commandBase {a_j} {\ s_{q}\!=\! \iota} {\lambda_j:\ s_{q}'\!=\!
  %         \left(s_{q} +1+\sum_{k=1}^{j-1}\mathsf{nodes}({C_k})}\right)\
  %         \&\ \projE {u_j}\nrr\right\}_{j\in J}
  %         \\
  %         \qquad\cup\ \bigcup_{j} \proj (\role q, C_j, \iota+1+\sum_{k=1}^{j-1}\mathsf{nodes}({C_k}))
          
  %         \\\\
  %         % \end{array}
  %         % \end{displaymath}
          
  %         % \begin{displaymath}\small
  %         %   \begin{array}{lr}
          
  %         \proj (\role q,\interactl{p}{a}{\role p_1,\ldots,\role p_n}, \iota)= 
  %         &  \!\!\!\!\!\! \!\!\!\!\!\!\boxed{\text{if }\role q\in\{\role p_1,\ldots,\role p_n\}}\\[2mm]
  %         \qquad
  %         % \{ 
  %         \left\{\commandBase {a_j} {\ s_{q}\!=\! \iota} {1:\ s_{q}'\!=\!
  %         \left(s_{q} +1+\sum_{k=1}^{j-1}\mathsf{nodes}({C_k})}\right)
  %         \ \&\ \projE {u_j}\nrr\right\}_{j\in J}
  %         \\
  %         \qquad\cup\ \bigcup_{j} \proj (\role q, C_j, \iota+1+\sum_{k=1}^{j-1}\mathsf{nodes}({C_k}))

  %         \\\\

  %         \proj (\role q,\interactl{p}a{\role p_1,\ldots,\role p_n}, \iota)=
  %         % \ \proj (\role{q}, C_1, \iota)
  %         &  \hspace{-1.8cm}\boxed{\text{if }\role q\not\in\{\role p, 
  %           \role p_1,\ldots,\role p_n\}}
  %         \\[2mm]

  %         \qquad\bigcup_{j} \proj (\role q, C_j, \iota+\sum_{k=1}^{j-1}\mathsf{nodes}({C_k}))

  %         \\\\

  %         \proj (\role q,\ifTE {E}{p}{C_1}{C_2}, \iota) = 
  %         &  \boxed{\text{if }\role q=\role p}\\[2mm]
  %         \qquad\left\{ 
  %         \begin{array}{lll}
  %           \commandBase {} {s_{q}\!=\! \iota\ \&\ E}{\ 1: s'_{q}\!=\! \iota+1},\\ 
  %           \commandBase {} {s_{q}\!=\! \iota\ \&\ \mathsf{not}(E)}
  %           {\ 1: s'_{q}\!=\! \iota+\mathsf{nodes}(C_1)+1}
  %         \end{array}
  %         \right\}
  %         \\[3mm]
  %         \qquad\cup\quad \proj (\role{p}, C_1, \iota+1)
  %         \quad\cup\quad
  %         \proj (\role{p}, C_2, \iota+\mathsf{nodes}(C_1)+1)
  %         \\\\

  %         \proj (\role q,\ifTE {E}{p}{C_1}{C_2}, \iota) = 
  %         % \ \proj (\role{q}, C_1, \iota)
  %         &  \boxed{\text{if }\role q\neq\role p}\\[2mm]
  %         %
  %         % \quad\cup\quad
  %         % \proj (\role{q}, C_2, \iota+\mathsf{nodes}(C_1)+1)
  %         % \\[2mm]


  %         \qquad \proj (\role{q}, C_1, \iota)
  %         \quad\cup\quad
  %         \proj (\role{q}, C_2, \iota+\mathsf{nodes}(C_1))


  %         % \qquad\text{such that if } 
  %         % % 
  %         % \forall i. 
  %         % % \role q\in C_i
  %         % \proj (\role{q}, C_i, \iota)\neq\emptyset
  %         % \text{ then } \proj (\role{q}, C_1, \iota)= \proj (\role{q}, C_2, \iota)

  %         \\\\

  %         \proj (\role q,\CEnd, \iota) = \emptyset

  %         \\\\

  %         \proj (\role q, X, \iota) = 
  %         \{ \commandBase {} {s_{q}\!=\! \iota}{\ 1: s'_{q}\!=\! \iota'} \}
  %         \qquad\text{ where } \textsf{defs}(X) = \iota'

  %       \end{array}
  %     \end{displaymath}
  %   \end{definition}
    \marco{text must fixed later, first get the proof done} We examine
    the various cases in the definition above. The first three cases
    deal with the projection of an interaction. When projecting the
    first module \( \role p \), we create one command
    $\commandBase {a_j} {s_{\role q}\!=\! \iota} {\lambda_j:\ s_{\role
        q}'\!=\!  s_{\role q}
      +1+\sum_{k=1}^{j-1}\mathsf{nodes}({C_k})}\ \&\ \projE
    {u_j}{\nrr}$ for each branch such that
    % 
    \begin{itemize}
    \item the label $a_j$ and its uniqueness ensure that all modules
      take the same branch;
    \item the guard $s_{\role q}\!=\! \iota$ ensures that these
      commands are only executable when the system has reached this
      particular state, identified by the reserved variable
      $s_{\role q}$;
    \item the rate $\lambda_j$ is the rate that appears in the same
      branch of the choreography
    \item the successor state is determined by incrementing
      $s_{\role q}$, depending on which branch was selected—the
      function $\mathsf{nodes}$ ensures that every interaction in all
      branches is assigned to a different counter value, thereby also
      discarding all branches that are not selected;
    \item the projected update $\projE {u_j}{\nrr}$ acts as a
      filter on the list of updates in $u_j$, ensuring that only those
      variables local to $\role q$ are updated.
    \end{itemize}
    %
    %
    Note that the translation works only with rates. In the case of
    probabilities, the definition above is incorrect, as we must
    ensure that the probabilities in a branching sum to 1.
    % Obviously, when projecting the next branch, we need to consider
    % all other possible branches that may have already been
    % projected. Intuitively, a label and an integer (denoted by
    % \( \iota \)) identify a node in the abstract syntax tree of a
    % choreography. Also, from a label \( a \), we generate distinct
    % sublabels \( a_j \) by simply adding an index \( j \).
    % % For the sake of space, we do not define the function precisely,
    % % but we observe that it could also be easily defined via the
    % % label annotations.

    The second case defines the projection of an interaction for one
    of the modules \( \{\role p_1, \ldots, \role p_n\} \). Similarly
    to the previous case, we define a command for each branch of the
    interaction. However, the rate of each command is set to 1,
    ensuring that each branch synchronises with probability
    \( \lambda_j \cdot 1 \) (see rule \( \mathsf{(P_2)} \) in
    Figure~\ref{fig:semantics}).
    %
    The third case is the one when we are projecting a module that is
    not in the set $\{\role p, \role p_1,\ldots,\role p_n\}$. % Our
    % projection takes a standard approach that requires each branch to
    % project the same~\cite{HYC16}. A generalisation of this, which may
    % require a merging operation~\cite{CHY12} and perhaps a more
    % intrinsic treatment of rates and probabilities, is left as future
    % work.
    % 
    % \marco{BEST TO COMMENT ON SELF-INTERACTION HERE and RELATED TO
    %   PROJECTION: The paper does nor require the usual condition of
    %   non-self-interaction (as evident in Listing 1.4). Additionally,
    %   clarification is needed on how projection works in cases where
    %   non-self-interaction is not enforced. Are the projection rules
    %   ordered? }
    The if-then-else construct focuses on the module $\role p$ where
    the guard $E$ must be evaluated. As a consequence, we do not need
    to have any label for synchronisation. 
    % As in the previous case, the other modules must project the same
    % in $C_1$ and $C_2$.
    For recursive calls, we generate a command that resets the counter
    to a distinct value given by the auxiliary function
    $\textsf{defs}$. 
    %As an example, we can apply the projection
    %function to Example~\ref{example2} and obtain the PRISM modules
    %from Example~\ref{example3}.

\begin{example}\label{example-proj}
  %
  In order to illustrate how our projection works, consider the
  following example, in which we apply the projection to the
  choreography $X$ from Example~\ref{example2}. This yields PRISM
  modules that are slightly different from those presented in
  Example~\ref{example3}, but which implement the same behaviour.
  %
  In Example \ref{example2}, we defined a recursive choreography in
  which role \(\role{p}\) interacts with role \(\role{q}\) through two
  branches. Its annotated form can be written as:
  \begin{displaymath}
    \begin{array}{lll}
      X \defrec \interactBasel{\nr}a{\nrr}
      \left\{
      \begin{array}{lll}
        \lambda_1: (x'=1)\&(y'=2);\ X^b
        \\
        \lambda_2: (x'=3)\&(y'=1);\ X^c
      \end{array}
      \right.
    \end{array}
  \end{displaymath}
  %
  % 
  Our projection, as defined in Definition~\ref{def:projCTMC}, when
  applied to a given choreography $X^d$ (which essentially corresponds
  to a recursive call), generates the following modules:
  %
  \begin{equation}\label{eq:1}
    \small
    \begin{array}{llll}
      \role{p}: \left\{
      \begin{array}{lll}
        \commandBase {d}{s_{\nr}=d} 
        {1:(s_{\nr}'=a) },
        \\
        \commandBase {a_1}{s_{\nr}=a} {\lambda_1:(x'=1)
        \ \&\ (s_{\nr}'=b)},
        & \quad \commandBase {b}{s_{\nr}=b} 
          {1:(s_{\nr}'=a) },\\
        \commandBase {a_2}{s_{\nr}=a} {\lambda_2:(x'=3)
        \ \&\ (s_{\nr}'=c)},
        & \quad \commandBase {c}{s_{\role p}=c} 
          {1:(s_{\role p}'=a) }
      \end{array}
      \right\}
      \\[7mm]
      \role{q}:
      \left\{
      \begin{array}{lll}
        \commandBase {d}{s_{\nrr}=d} 
        {1:(s_{\nrr}'=a) },
        \\
        \commandBase {a_1}{s_{\role q}=a} {1:(y'=2)
        \ \&\ (s_{\role q}'=b) }, 
        & \quad \commandBase {b}{s_{\role q}=b} 
          {1:(s_{\role q}'=a) }, \\
        \commandBase {a_2}{s_{\role q}=a} {1:(y'=1)
        \ \&\ (s_{\role q}'=c) },
        & \quad \commandBase {c}{s_{\role q}=c} 
          {1:(s_{\role q}'=a) }
      \end{array}
      \right\}
    \end{array}
  \end{equation}
  %
  % From label $a$, each branch of the choreography is identified by a
  % unique label, say $a_1$ for the first branch and $a_2$ for the
  % second. 
  The core idea is that we use reserved variables $s_{\nr}$ and
  $s_{\nrr}$ to track the state of each module, in order to simulate
  the behaviour of the choreography.
  %
  The various steps of the projection can then be summarised as
  follows:
  \begin{enumerate}
  \item We first project \(X^d\), which is annotated with the unique
    identifier \(d\). This generates the commands
    \(\commandBase{d}{s_{\nr}=d}{1:(s_{\nr}'=a)}\) and
    \(\commandBase{d}{s_{\nrr}=d}{1:(s_{\nrr}'=a)}\) for \(\nr\) and
    \(\nrr\), respectively.  Since \(X^d\) is the starting
    choreography, we assume that all PRISM modules initially start in
    a state where the reserved variables satisfy \(s_{\nr}=d\) and
    \(s_{\nrr}=d\).  The intention is that the commands of the two
    modules synchronise on \(d\) and then activate the first action,
    labelled \(a\), in the body of \(X\).
    
  \item Separately, we must project the bodies of all definitions in
    \(\defin\). In our case, we project
    \[
      \interactBasel{\nr}{a}{\nrr}
      \left\{
        \begin{array}{lll}
          \lambda_1 : (x'=1)\ \&\ (y'=2);\ X^b \\[0.5mm]
          \lambda_2 : (x'=3)\ \&\ (y'=1);\ X^c
        \end{array}
      \right.
    \]
    % 
    The first step of the projection ensures that this interaction is
    enabled only when the variables \(s_{\nr}\) and \(s_{\nrr}\) are
    equal to the label \(a\). The operation has two possible outcomes:
    either a synchronisation on label \(a_1\) with rate \(\lambda_1\),
    or a synchronisation on label \(a_2\) with rate \(\lambda_2\).  In
    the first case, both \(s_{\nr}\) and \(s_{\nrr}\) are set to \(b\)
    (since \(\topannotation{\nr}{X^b}=b\)). In the second case, both
    \(s_{\nr}\) and \(s_{\nrr}\) are set to \(c\).
    %
    Thus, each branch is assigned a unique state to ensure that only
    one transition can be taken at a time in the PRISM model. The
    recursive nature of the choreography ensures that the reserved
    variables return to label $a$ after each interaction, allowing the
    process to repeat.
    %
    This is done as in the projection of \(X^d\), linking the flow of
    execution back to a state in which \(s_{\nr}\) and \(s_{\nrr}\)
    are both set again to \(a\).

  \end{enumerate}


  
  % \begin{enumerate}
  % \item \textbf{Computing the States.} Starting from a state where
  %   reserved variable \( s_{\role{p}} = d \) and reserved variable
  %   \( s_{\role{q}} = d \), we apply our projection function to
  %   determine the new state values for each interaction.
  %   % The auxiliary function \(\mathsf{nodes}(C)\) counts the steps
  %   % within each branch of the choreography.
  %   Since each branch in Example \ref{example2} consists of a single
  %   interaction followed by a recursive call to \(C\), the state
  %   updates will be
  %   %
  %   \( s_{\nr}' = b \) and \( s_{\nrr}' = b \)
  %   %
  %   or
  %   %
  %   \( s_{\nr}' = c \) and \( s_{\nrr}' = c \)
  %   % 
  %   depending on the branch.
  %   %
  %   % In particular, for the \(j^{\text{th}}\) branch, the new state is
  %   % given by $ \iota + 1 + \sum_{k=1}^{j-1} \mathsf{nodes}(C_k) $.
  %   % %
  %   % Applying this formula to our example:
  %   % \begin{enumerate}
  %   % \item Branch \(\lambda_1\) (label \(a_1\)):
  %   %   \begin{itemize}
  %   %   \item The initial state is \( s_{\role{p}} = 0 \) and
  %   %     \( s_{\role{q}} = 0 \).
  %   %   \item in the first branch ($j=1$), the sum
  %   %     $\sum_{k=1}^{j-1} \mathsf{nodes}(C_k)$ is equal to $0$,
  %   %     therefore
  %   %     \[
  %   %       s'_{\role{p}} = 0 + 1 = 1, \quad s'_{\role{q}} = 0 + 1 = 1
  %   %     \]
  %   %   \item The update rule for this branch is
  %   %     $s_{\role{p}}' = 1 \quad \& \quad s_{\role{q}}' = 1$
  %   %   \end{itemize}
  %   % \item Branch \(\lambda_2\) (label \(a_2\)):
  %   %   \begin{itemize}
  %   %   \item Again, starting from \( s_{\role{p}} = 0 \) and
  %   %     \( s_{\role{q}} = 0 \).
  %   %   \item in the second branch ($j=2$), the sum
  %   %     $\sum_{k=1}^{j-1} \mathsf{nodes}(C_k)$ is equal to $1$ because
  %   %     the first branch contains only the recursive call to
  %   %     $C$. Hence,
  %   %     \[
  %   %       s'_{\role{p}} = 0 + 2 = 2, \quad s'_{\role{q}} = 0 + 2 = 2
  %   %     \]
  %   %   \item The update rule for this branch is
  %   %     $s_{\role{p}}' = 2\quad\& \quad s_{\role{q}}' = 2$
  %   %   \end{itemize}
  %   % \end{enumerate}
  %   Thus, each branch is assigned a unique state to ensure that only
  %   one transition can be taken at a time in the PRISM model. The
  %   recursive nature of the choreography ensures that the reserved
  %   variables return to $a$ after each interaction, allowing the
  %   process to repeat.

  % \item \textbf{Assigning Unique Labels.}  For each branch, a unique
  %   label is generated from the interaction’s base label. In this
  %   example, the first branch is assigned label \(a_1\) and the second
  %   \(a_2\). These labels serve as synchronisation points between the
  %   interacting modules. In our projection, role \(\role{p}\) (the
  %   initiator) uses the corresponding rates (\(\lambda_1\) and
  %   \(\lambda_2\)) while role \(\role{q}\) uses a fixed rate (equal to
  %   1) for synchronisation.

  % \item \textbf{From Choreography to PRISM.} As detailed in
  %   Example \ref{example3}, the projected PRISM network is obtained by
  %   creating commands for each branch in both roles. Each command is
  %   guarded by a condition on the state counter (for instance,
  %   \(s_{\role p}=0\) for the first branch) and includes the update
  %   that sets the counter to the new state computed above. The modules
  %   for \(\role{p}\) and \(\role{q}\) synchronise on the unique labels
  %   \(a\) and \(b\), and the overall system's global transitions
  %   (e.g. \(F_1\) and \(F_2\)) are derived by the composition of these
  %   synchronised commands. The rates of these transitions are computed
  %   as the product of the individual rates (i.e.,
  %   \(\lambda_i = \mu_i * \gamma_i\)).
  % \end{enumerate}

\end{example}

    As hinted above, the projection in Definition~\ref{def:projCTMC}
    would be incorrect if instead of using rates we used
    probabilities. This is simply because we cannot force both
    $\role p$ and $\{\role p_1,\ldots,\role p_n\}$ to take the same
    branch with the probability distribution of the $\lambda_i$'s. To
    fix this problem, we have the following definition instead:
    % 
    \begin{definition}[Projection, DTMC]\label{def:projDTMC} Given an annotated
      choreography with probabilities $C$, a module $\role p$, and a
      natural number $\iota$, we define $\proj$ as:
      \begin{displaymath}\small
        \begin{array}{lr}

          \proj (\role q,\interact{p}{\role p_1,\ldots,\role p_n}, \iota)= 
          &  \boxed{\text{if }\role q=\role p}\\[2mm]
          \qquad
          \left\{
          \begin{array}{lll}
            \commandBase {} {s_{q}\!=\! \iota}{\ \sum_{j\in J} \lambda_j: s'_{q}\!=\! \iota+1+j},\\ 
            \{\commandBase {l_j} {s_{q}\!=\! \iota+1+j}
            \ 1: s'_{q}\!=\! \iota+1+\sum_{k=1}^{j-1}\mathsf{nodes}({C_k})\ \&\ \projE
            {u_j}\nrr\}_{j\in J}
          \end{array}
          \right\}
          \\
          \qquad\cup\ \bigcup_{j} \proj (\role q, C_j, s+1+\sum_{k=1}^{j-1}\mathsf{nodes}({C_k}))
          \\\\

        \end{array}
      \end{displaymath}
      The other cases of the definition are equivalent to those in
      Definition \ref{def:projCTMC}.
    \end{definition}
    The fix is immediate: module $\role p$ takes a (probabilistic)
    internal decision on the $j^{\text{th}}$ branch and then
    synchronises on label $l_j$ with $\{\role p_1,\ldots,\role p_n\}$.       

\smallskip

\subsection{Correctness.} Our projection operations are correct with
respect to the semantics of choreographies and PRISM.
%
In order to state our main result, we need to use the notions of {\em
  head modules} and {\em strongly connected} choreography. The former
identifies the modules involved in the next action of a choreography:
\begin{definition}[Head Modules]
  The function $\hmodules$ is defined as follows:
  \begin{displaymath}\small
    \begin{array}{rll}
      \hmodules(\interact{\nr}{\nr_1,\ldots,\nr_n})\
      & = \ \{\nr, \nr_1,\dots,\nr_n\}\\[1mm]
      \hmodules(\ifTE {E}{\nr}{C_1}{C_2}) \ & =\ \{\nr\}\\
      \hmodules(X) \ & =\ \hmodules (C)\qquad\qquad(\text{if }
                       X\defrec C\in\defin)\\[1mm]
      \hmodules(\CEnd) \ & =\ \emptyset
    \end{array}
  \end{displaymath}
\end{definition}
Then, the property of strongly connected is defined below.
%
\begin{definition}[Strongly Connected Choreography]
  A choreography $C$ is \emph{strongly connected}, written
  $\sconnected(C)$, if it satisfies the following conditions:
  \begin{displaymath}\small
    \begin{array}{c}
      \infer {
      \sconnected(\interact{p}{\role p_1,\ldots,\role p_n})
      } {
      \forall j\in J.\ \sconnected(C_j)\ \land\ \hmodules(C_j)\neq\emptyset\Rightarrow \hmodules(C_j)\cap\{\role p, \role p_1,\dots,\role p_n\}\neq\emptyset
      }      



      \qquad\qquad

      \infer {
      \sconnected(\CEnd)
      } {
      }
      \\\\

      \infer {
      \sconnected(\ifTE {E}{\nr}{C_1}{C_2})
      } {
      \forall j\in \{1,2\}.\ \sconnected(C_j)\ \land\ \hmodules(C_j)
      \neq\emptyset\Rightarrow \role p\in\hmodules(C_j)
      }      

      \qquad\qquad
      \infer {
      \sconnected(X)
      } {
      \sconnected(C)\qquad X\defrec C\in\defin
      % &\text{\marco{is this wrong? Annotate? } }
        }

      \\\\


    \end{array}
  \end{displaymath}
\end{definition}
%
Note that the definition above is coinductive but decidable.  The
notion of connectedness is quite well-known in the literature. Since
our framework is based on synchronous communication, we follow the
same approach as that of Carbone et al.~\cite{CHY12}. The basic idea
is that each interaction shares at least one module with the
subsequent choreography. In particular, in every branch of a
probabilistic choice or an if-then-else involving modules
$\role p_1, \ldots, \role p_n$, the first action (if any) of every
other module $\role q$ must be an interaction with one of
$\role p_1, \ldots, \role p_n$, possibly after unfolding recursive
calls.
%
For example, the choreography $X$, obtained from the definition
\begin{displaymath}\small
  X\defrec
  \interactBase{\nr}{\nrr}:\,
  \left(
    \begin{array}{l}
      \lambda_1: u_1;\ \interactBase{\nrr}{\nrrr}:\, \lambda_1':u_1';\ X    \\
      \lambda_2: u_2;\ X
    \end{array}
  \right)
\end{displaymath}
%
is strongly connected while 
% 
$
\interactBase{\nr}{\nrr}:\,
\left(
  \begin{array}{l}
    \lambda_1: u_1;\ \interactBase{\nrrr_1}{\nrrr_2}:\, \lambda_1':u_1';\ \CEnd.
  \end{array}
\right) $ is not.
% 

%%%%  THIS LEMMA HERE MEANS NOTHING AS IT IS STATED
% Then, we can state the following Lemma which identifies some
% uniqueness properties of projections. 
% \begin{lemma}
%   The state of a projected choreography is uniquely identified by the
%   counter $\iota$.
% \end{lemma}

\smallskip

% We are now ready for our main theorem. In the sequel, $S_+$ is
% obtained from state $S$ by extending its domain with the extra
% variables $s_{\role q}$ (one for each module in a choreography) used
% by the projection.  In the projection, we utilize alphabetised
% parallel composition $\pp$, wherein modules synchronise solely on
% labels that appear in both modules.
We are now ready to state our main theorem, which relates a
(projectable, strongly connected) choreography with its PRISM
projection.  In the sequel, $S_+$ denotes the extension of a global
state $S$ with the additional reserved variables $s_{\nrr}$ (one for
each role $\role q$), introduced by the projection.  The projection
uses alphabetised parallel composition~$\pp$, where modules
synchronise only on shared labels.

The theorem departs from standard projection results for choreography
languages.  In most settings, both choreographies and endpoints are
expressed in a process algebra in which control flow is encoded
syntactically, and correctness is shown by relating reductions of
programs.  PRISM, instead, is declarative: a module consists of a
fixed set of commands, and execution is driven solely by state changes
through the enabling of commands.
%
Our choreography language combines both aspects.  Although it
maintains an explicit runtime state for variables, its syntax
determines the next action to be executed.  The projection reconciles
this mismatch by encoding control-flow information into the state: the
variables $s_{\role q}$ act as a distributed program counter, yielding
the extended state $S_+$.
%
Consequently, choreography reduction corresponds in the projection to
transitions on $S_+$ rather than to syntactic changes of PRISM
modules.  This induces an apparent asymmetry: reducing a choreography
before projection may result in fewer commands than projecting first,
whereas PRISM execution never alters the set of commands.  Our main
theorem shows that this asymmetry is benign: the observable behaviour
of the projected model is completely determined by the evolution of
the extended state $S_+$, which faithfully captures choreography
execution.
%


\begin{theorem}[Projection]\label{thm:epp}
  Let $C$ be an annotated choreography such that $\sconnected(C)$, and
  let $S_+$ be an extension of a global state $S$ such that for all
  $\nrr\in C$, we have that $S_+(s_{\nrr})=\topannotation\nrr C$.
  Then,
  \[
    (S, C) \red{\lambda} (S', C')
    \quad\text{if and only if}\quad
    \pp_{\role q\in C}\ \proj(\role q, C)\ \vdash\
    S_+ \red{\lambda} S_+' ,
  \]
  such that: 
  \begin{itemize}
  \item for all $\nrr\in C$, we have that
    $\proj(\role q, C') \subseteq \proj(\role q, C)$
  \item $S'=S'_{+}\backslash \{s_{\nrr}\}_{\nrr\in C}$
  \item for all $\nrr\in C$, we have that
    $S_+'(s_{\nrr}) = \topannotation\nrr {C'}$
  \end{itemize}
\end{theorem}
%
% PROOF
%
\begin{proof}
  The proof proceeds by induction on $C$.
  \begin{itemize}
  \item $C=\interact{p}{\role p_1,\ldots,\role p_n}$.  By (the only
    applicable) rule \textsf{(Interact)}, we have that
    % 
    \[
      (S, \interact{p}{\role p_1,\ldots,\role p_n})
      \red{\lambda_j} (S[u_j], C_j) 
    \]
    % 
    By definition of projection, we obtain the following PRISM
    commands. Role $\role p$ is projected as:
    \[
      \Big\{\commandBase {a_j} {\ s_{\role p}\!=\! \iota} {\lambda_j:\ s_{\role p}\!=\!
        s_{\role p} +1+\sum_{k=1}^{j-1}\mathsf{nodes}({C_k})}\ \&\ \projE
      {u_j}{\nr}\Big\}_{j\in J}
      \ \cup\ \bigcup_{j} \proj (\role q, C_j,
      \iota+1+\sum_{k=1}^{j-1}\mathsf{nodes}({C_k}))
    \]
    Roles $\role{p_i}$ are projected as:
    \[
      \Big\{\commandBase {a_j} {\ s_{\role p_i}\!=\! \iota} {1:\ s_{\role p_i}\!=\!
        s_{\role p_i} +1+\sum_{k=1}^{j-1}\mathsf{nodes}({C_k})}\ \&\ 
       \projE{u_j}{\nr_i}\Big\}_{j\in J}
      \ \cup\ \bigcup_{j} \proj (\role p_i, C_j, \iota+1+\sum_{k=1}^{j-1}\mathsf{nodes}({C_k}))
    \]
    %
    while any other role is projected as: 
    \[\bigcup_{j} \proj (\role q, C_j, \iota+\sum_{k=1}^{j-1}\mathsf{nodes}({C_k}))
    \]
    We need to show two things: first, that the projection above can
    make the same transition; second, that if the projection makes a
    transition, it must be corresponding to that of the choreography
    above.
    %
    Observe that the state of a generated CTMC is uniquely identified
    by the counter $\iota$.  The uniqueness of the label $a$
    (Assumption~1) makes sure that all and only those modules involved
    in this interaction synchronise with this action (this shows from
    the rules in Figure~\ref{fig:semantics}).  As a consequence of
    this and since choreographies are strongly connected, the commands
    generated by this step of the translation are such that any state
    $S_+$ is exclusively going to enable these commands (because of
    the guard $s_{\role q}=\iota$) which obviously implies that it
    must be done with rate $\lambda_j$ applying the rules in
    Figure~\ref{fig:semantics}. This argument is key for proving both
    directions of the if and only if.

  \item $C=\ifTE {E}{p}{C_1}{C_2}$. In this case, the projection of
      $\role p$ is
      \begin{equation*}
        \begin{array}{lll}
          \left\{ 
          \begin{array}{lll}
            \commandBase {} {s_{\role p}\!=\! \iota\ \&\ E}{\ 1: s'_{\role p}\!=\! \iota+1},\\ 
            \commandBase {} {s_{\role p}\!=\! \iota\ \&\ \mathsf{not}(E)}
            {\ 1: s'_{\role p}\!=\! \iota+\mathsf{nodes}(C_1)+1}
          \end{array}
          \right\}
          \qquad\cup\quad 
          \\\\
          \qquad\proj (\role{p}, C_1, \iota+1)
          \quad\cup\quad
          \proj (\role{p}, C_2, \iota+\mathsf{nodes}(C_1)+1)
        \end{array}
      \end{equation*}
      while, for all other roles, we have
      \begin{equation*}
          \qquad \proj (\role{q}, C_1, \iota)
          \quad\cup\quad
          \proj (\role{q}, C_2, \iota+\mathsf{nodes}(C_1))
      \end{equation*}
      In this case, role $\role p$ is enabled by the counter. All
      other roles are not enabled simply because we assume that the
      choreography is strongly connected; hence, any other
      synchronisation or if-then-else statement is blocked, as it must
      involve $\role p$ (on a different counter value).

    \item $C=X$, and $C=\CEnd$. Similar to the other case.

  \item $C=X^a$. By definition, assuming $X\defrec C_X\in \defin$, it
    must be the case that, for all $\nrr\in C$:
    \[\proj (\nrr, X^a) = \{ \commandBase {a} {s_{\nrr}\!=\! a}{\ 1:
        s'_{\nrr}\!=\! }
      \mathsf{top}_{\nrr}(C)\}\qquad\cup\quad\bigcup_{(Y\defrec
        C_Y)\in\defin}\big(\proj (\nrr, C_Y)\big)\]
    %
    We now show both directions.
    \begin{itemize}
    \item (only if). Here, we know that $(S, X^a) \red{1} (S,
      C_X)$. From the uniqueness of $a$, we can derive
      $\pp_{\role q\in C}\ \proj(\role q, C)\ \vdash\ S_+
      \red{\lambda} S_+'$ by applying rule (\textsf{M}) on each
      module, then rule (\textsf{P$_2$}), and finally rule
      (\textsf{Transition}).
      % 
      Moreover, we observe that the command
      $s'_{\nrr}\!=\!  \mathsf{top}_{\nrr}(C)$ has no effect on the
      state except modifying the extended variables with the top
      annotation in $C$ which, by assumption again, it is
      unique. Additionally, we observe that for all $\nrr\in C$, we
      have that $\proj(\role q, C') \subseteq \proj(\role q,
      C)$. Finally, for all $\nrr\in C$, we have that
      $S_+'(s_{\nrr}) = \topannotation\nrr {C'}$.

    \item (if). In this direction, we just observe that, for all
      $\nrr$, the extended state variables $s_{\nrr}$ are all set to
      $a$. Therefore, given uniqueness of annotations, the projected
      modules can only simulate the procedure call.

    \end{itemize}


    
  \end{itemize}
        The case for DTMC is also similar.

     
\end{proof}


\begin{remark}
  % 
  We now compare the semantics of the choreography \(X^d\), obtained
  from the recursive definition in Example~\ref{example2}, with that
  of its projection from Example~\ref{example-proj}. Starting from a
  state \(S_0\) in which \(x=0\) and \(y=0\), and from its extension
  \(S_0^+\), where additionally \(s_{\nr}=d\) and \(s_{\nrr}=d\), both
  the choreography and its projection from Equation~\ref{eq:1} admit a
  single possible transition:
  \begin{displaymath}
    \begin{array}{lll}
      (S_0,\ X^d)\red 1
      \left(S_0,\ \interactBasel{\nr}{a}{\nrr}
      \left\{
      \begin{array}{lll}
        \lambda_1 : (x'=1)\ \&\ (y'=2);\ X^b \\[0.5mm]
        \lambda_2 : (x'=3)\ \&\ (y'=1);\ X^c
      \end{array}
      \right.\right)
      \\\\
      \pp_{\nrrr\in X^d}\ \proj (\nrrr, X^d)\vdash S_{+}
      \red{\lambda} S_{+}[s_{\nr}'=a][s_{\nrr}'=a]
    \end{array}
  \end{displaymath}
  Clearly, the projection of the unfolding of \(X^d\) is still
  contained in the projection of \(X^d\). This is because the
  interaction \(\interactBasel{\nr}{a}{\nrr}\{\dots\}\) is projected
  twice: once when projecting the reductum, and once when projecting
  the definition of \(X\). On the other hand, the commands
  \(\commandBase{d}{s_{\nr}=d}{1:(s_{\nr}'=a)}\) and
  \(\commandBase{d}{s_{\nrr}=d}{1:(s_{\nrr}'=a)}\) are no longer
  generated.

  In an attempt to correctly annotate the resulting choreography,
  while avoiding name clashes with the recursive definitions, we would
  obtain the choreography
  \[
    \left(S_0,\ \interactBasel{\nr}{a'}{\nrr}
      \left\{
        \begin{array}{lll}
          \lambda_1 : (x'=1)\ \&\ (y'=2);\ X^{b'} \\[0.5mm]
          \lambda_2 : (x'=3)\ \&\ (y'=1);\ X^{c'}
        \end{array}
      \right.\right)
  \]
  and its projection (which we denote by \(N\)):
  \begin{displaymath}
    \small
    \begin{array}{llll}
      \role{p}: \left\{
      \begin{array}{lll}
        \commandBase{a_1'}{s_{\nr}=a'}{\lambda_1:(x'=1)\ \&\ (s_{\nr}'=b')},
        & \quad \commandBase{b'}{s_{\nr}=b'}{1:(s_{\nr}'=a)},\\
        \commandBase{a_2'}{s_{\nr}=a'}{\lambda_2:(x'=3)\ \&\ (s_{\nr}'=c')},
        & \quad \commandBase{c'}{s_{\role p}=c'}{1:(s_{\role p}'=a)}
        \\
        \commandBase{a_1}{s_{\nr}=a}{\lambda_1:(x'=1)\ \&\ (s_{\nr}'=b)},
        & \quad \commandBase{b}{s_{\nr}=b}{1:(s_{\nr}'=a)},\\
        \commandBase{a_2}{s_{\nr}=a}{\lambda_2:(x'=3)\ \&\ (s_{\nr}'=c)},
        & \quad \commandBase{c}{s_{\role p}=c}{1:(s_{\role p}'=a)}
      \end{array}
      \right\}
      \\[1cm]
      \role{q}: \left\{
      \begin{array}{lll}
        \commandBase{a_1'}{s_{\role q}=a'}{1:(y'=2)\ \&\ (s_{\role q}'=b')},
        & \quad \commandBase{b'}{s_{\role q}=b'}{1:(s_{\role q}'=a)}, \\
        \commandBase{a_2'}{s_{\role q}=a'}{1:(y'=1)\ \&\ (s_{\role q}'=c')},
        & \quad \commandBase{c'}{s_{\role q}=c'}{1:(s_{\role q}'=a)}
        \\
        \commandBase{a_1}{s_{\role q}=a}{1:(y'=2)\ \&\ (s_{\role q}'=b)},
        & \quad \commandBase{b}{s_{\role q}=b}{1:(s_{\role q}'=a)}, \\
        \commandBase{a_2}{s_{\role q}=a}{1:(y'=1)\ \&\ (s_{\role q}'=c)},
        & \quad \commandBase{c}{s_{\role q}=c}{1:(s_{\role q}'=a)}
      \end{array}
      \right\}
    \end{array}
  \end{displaymath}
  We observe that the PRISM model obtained by projecting the reductum
  \(\interactBasel{\nr}{a}{\nrr}\{\dots\}\), starting from the state
  \(S_{+}[s_{\nr}'=a][s_{\nrr}'=a]\), exhibits the same behaviour as
  the model \(N\) starting from the state
  \(S_{+}[s_{\nr}'=a'][s_{\nrr}'=a']\).  Relating these two states
  would require a suitable notion of equivalence induced by the
  semantics of PRISM, which we leave as future work. We conjecture
  that, under an appropriate equivalence notion, such as probabilistic
  bisimulation, our theorem could be extended to capture this
  additional feature.
\end{remark}



%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "main"
%%% End:
