In this section, we provide a rigorous treatment of projection, which
constitutes the mapping from choreographies to the PRISM language.
%

\subsection{Mapping Choreographies to PRISM} 
%
The process of generating endpoint code from a choreography is
commonly referred to as \emph{projection}. Typically, projection is
defined separately for each module appearing in the choreography
program, that is, given a module (often called a role) and a
choreography, it generates the code for that particular module.
%
In our approach, projection targets PRISM modules and is realised
using the mechanisms provided by the PRISM modelling language. In
particular, a choreography interaction is simulated in PRISM by using
(i) labels on which the involved modules synchronise and (ii) state
variables that enable the appropriate commands at the correct points
in the execution.
%

Before formalising this idea, we introduce additional machinery that
allows us to define projection.
%
To this end, we annotate choreographies with labels. We refer to such
choreographies as \emph{annotated choreographies}. Formally,
\begin{definition}[Annotated Choreography]
  An \emph{annotated choreography} is obtained from the choreography
  syntax by adding a label (from $\mathcal L$) to each interaction:
  \[
    C::=\interactl{\nr}a{\nr_1,\ldots,\nr_n}
    \ \mid\  \ifTEl {E}a{\nr}{C_1}{C_2}
      \ \mid\  X^a \ \mid\  \CEnd^a
    \]
\end{definition}
%
The intuition behind annotations is that they allow us to identify a
particular point in the choreography, enabling all modules involved to
synchronise. Since these annotations must be unique, we make the
following assumption, which is key to our results:
\begin{assumption}\label{ass:1}
  Each label in an annotated choreography occurs exactly once.
\end{assumption}
% This assumption above ensures that every interaction can be uniquely
% identified and referenced in the corresponding endpoint projection. 
As an example, the following choreography is annotated correctly:
% 
\[
  \interactBasel{\nr}a{\nrr,\nrrr}:
  \left(
    \begin{array}{ll}
      \lambda_1: \ \CEnd^b \\
      \quad+\\
      \lambda_2:\
      % 
      \ifTEl {E}c{\nr}{\ \interactBasel{\nr}d{\nrr}: \lambda_1: \CEnd^e\ }{\CEnd^f}
    \end{array}
  \right)
\]
  % 
while, the one below is not: 
% 
\[
  \interactBasel{\nr}a{\nrr,\nrrr}:
  \left(
    \begin{array}{ll}
      \lambda_1: \ \CEnd^b \\
      \quad+\\
      \lambda_2:\
      % 
      \ifTEl {E}c{\nr}{\ \interactBasel{\nr}a{\nrr}: \lambda_1: \CEnd^e\ }{\CEnd^f}
    \end{array}
  \right)
\]
% 

\bigskip

Additionally, given a label $a$ and a set of indices $I$, the set
$\{a_i|i\in I\}$ contains unique identifiers generated from $a$.

We now define the projection function. Since there are key differences
between using probabilities and using rates, we proceed separately. We
begin with choreographies that involve rates: 
% 
\begin{definition}[Projection, CTMC]\label{def:projCTMC} Given an
  annotated choreography with rates $C$, a module $\nrr$, and
  $J=\{1,\dots,m\}$, we define the function $\proj$ as:
  \begin{displaymath}\small
    \begin{array}{lr}

      \proj (\role q,\interactl{\nr}{a}{\nr_1,\ldots,\nr_n})= 
      &  \boxed{\text{if }\nrr=\nr}\\[2mm]
      \quad
      % \{ 
      \left\{\commandBase {a_j} {\ s_{\nrr}\!=\! a} {\lambda_j:}
      \ s_{\nrr}'\!=\! \mathsf{top}_{\nrr}(C_j)\ 
      \&\ \projE {u_j}\nrr\right\}_{j\in J}
      \ \ \cup\ \ \bigcup_{j\in J} \proj (\nrr, C_j)
      
      \\[1cm]

          
      \proj (\nrr,\interactl{\nr}{a}{\nr_1,\ldots,\nr_n})= 
      &  \boxed{\text{if }
        \nrr\in\{\role p_1,\ldots,\role p_n\}}\\[2mm]
      \quad
      \left\{\commandBase {a_j} {\ s_{\nrr}\!=\! a} {1:\ s_{\nrr}'\!=\!
      \mathsf{top}_{\nrr}(C_j)
      }
      \ \&\ \projE {u_j}\nrr\right\}_{j\in J}
      \ \ \cup\ \ \bigcup_{j\in J} \proj (\role q, C_j)
      
      \\[1cm]
      
      \proj (\nrr,\interactl{\nr}a{\nr_1,\ldots,\nr_n})\ =
      \ \bigcup_{j\in J} \proj (\role q, C_j)
      &  \hspace{-2cm}\boxed{\text{if }\role q\not\in\{\role p, 
        \nr_1,\ldots,\nr_n\}}

      \\[1cm]

      \proj (\nrr,\ifTEl {E}a{\nr}{C_1}{C_2}) = 
      &  \boxed{\text{if }\nrr=\nr}\\[2mm]
      \quad\left\{ 
      \begin{array}{lll}
        \commandBase {} {s_{\nrr}\!=\! a\ \&\ E}{\ 1: s'_{\nrr}\!=\!
        \mathsf{top}_{\nrr}(C_1)},\\ 
        \commandBase {} {s_{\nrr}\!=\! a\ \&\ \mathsf{not}(E)}
        {\ 1: s'_{\nrr}\!=\! \mathsf{top}_{\nrr}(C_2)}
      \end{array}
      \right\}
      \ \cup\ \proj (\nrr, C_1)
      \ \cup\
      \proj (\nrr, C_2)
      \\[1cm]

      \proj (\nrr,\ifTEl {E}a{\nr}{C_1}{C_2}) \ =\
      \proj (\nrr, C_1)
      \ \cup\
      \proj (\nrr, C_2)

      &  \boxed{\text{if }\nrr\neq\nr}
      

      \\[1cm]

      \proj (\nrr,\CEnd) = \emptyset

      \qquad\qquad

      \proj (\nrr, X^a) = 
      \{ \commandBase {a} {s_{\nrr}\!=\! a}{\ 1: s'_{\nrr}\!=\! } \mathsf{top}_{\nrr}(C)\}
      &\boxed{X\stackrel{\textcolor{sh_keyword}{\mathsf{def}}}{=} C\in\defin}

    \end{array}
  \end{displaymath}
\end{definition}
We examine the various cases in the definition above. The first three
cases deal with the projection of an interaction. When projecting the
first module $\nr$, we create one command
$\commandBase {a_j} {s_{\nrr}\!=\! a} {\lambda_j:\ s_{\role q}'\!=\!
  \topannotation \nrr{C_j}}\ \&\ \projE {u_j}{\nrr}$ for each branch
such that
% 
\begin{itemize}
\item the label $a_j$ and its uniqueness ensure that all modules take
  the same branch;
\item the guard $s_{\role q}\!=\! a$ ensures that these commands are
  only executable when the system has reached this particular state,
  identified by the reserved variable $s_{\role q}$;
\item the rate $\lambda_j$ is the rate that appears in the same branch
  of the choreography
\item the successor state is determined by updating $s_{\role q}$ to
  $\topannotation \nrr{C_j}$, depending on which branch $j$ was
  selected. Assumption~\ref{ass:1} ensures that every other step in
  all branches is assigned to a different label, thereby also
  discarding all branches that are not selected;
\item the projected update $\projE {u_j}{\nrr}$ acts as a filter on
  the list of updates in $u_j$, ensuring that only those variables
  local to $\role q$ are updated.
\end{itemize}

The second case defines the projection of an interaction for one of
the modules \( \{\role p_1, \ldots, \role p_n\} \). Similarly to the
previous case, we define a command for each branch of the
interaction. However, the rate of each command is set to~1, ensuring
that each branch synchronises with rate \( \lambda_j \cdot 1 \) (see
rule \( \mathsf{(P_2)} \) in Figure~\ref{fig:semantics}).
% 
The third case concerns the projection of a module that does not
belong to the set \( \{\nr, \nr_1,\ldots,\nr_n\} \). The
if--then--else construct focuses on the module \( \nr \), where the
guard \(E\) is evaluated. As a consequence, no synchronisation labels
are required. For recursive calls, we generate a command that
redirects the execution to the projection of the definitions
\(\defin\), which are projected separately and are assumed to be
uniquely annotated.

\begin{example}\label{example-proj}
  %
  In order to illustrate how our projection works, consider the
  following example, in which we apply the projection to the
  choreography $X$ from Example~\ref{example2}. This yields PRISM
  modules that are slightly different from those presented in
  Example~\ref{example3}, but which implement the same behaviour.
  %
  In Example \ref{example2}, we defined a recursive choreography in
  which module \(\nr\) interacts with role \(\nrr\) through two
  branches. Its annotated form can be written as:
  \begin{displaymath}
    \begin{array}{lll}
      X \defrec \interactBasel{\nr}a{\nrr}
      \left\{
      \begin{array}{lll}
        \lambda_1: (x'=1)\&(y'=2);\ X^b
        \\
        \lambda_2: (x'=3)\&(y'=1);\ X^c
      \end{array}
      \right.
    \end{array}
  \end{displaymath}
  %
  % 
  Our projection, as defined in Definition~\ref{def:projCTMC}, when
  applied to a given choreography $X^d$ (which essentially corresponds
  to a recursive call), generates the following modules:
  %
  \begin{equation}\label{eq:1}
    \small
    \begin{array}{llll}
      \role{p}: \left\{
      \begin{array}{lll}
        \commandBase {d}{s_{\nr}=d} 
        {1:(s_{\nr}'=a) },
        \\
        \commandBase {a_1}{s_{\nr}=a} {\lambda_1:(x'=1)
        \ \&\ (s_{\nr}'=b)},
        & \quad \commandBase {b}{s_{\nr}=b} 
          {1:(s_{\nr}'=a) },\\
        \commandBase {a_2}{s_{\nr}=a} {\lambda_2:(x'=3)
        \ \&\ (s_{\nr}'=c)},
        & \quad \commandBase {c}{s_{\role p}=c} 
          {1:(s_{\role p}'=a) }
      \end{array}
      \right\}
      \\[7mm]
      \nrr:
      \left\{
      \begin{array}{lll}
        \commandBase {d}{s_{\nrr}=d} 
        {1:(s_{\nrr}'=a) },
        \\
        \commandBase {a_1}{s_{\role q}=a} {1:(y'=2)
        \ \&\ (s_{\role q}'=b) }, 
        & \quad \commandBase {b}{s_{\role q}=b} 
          {1:(s_{\role q}'=a) }, \\
        \commandBase {a_2}{s_{\role q}=a} {1:(y'=1)
        \ \&\ (s_{\role q}'=c) },
        & \quad \commandBase {c}{s_{\role q}=c} 
          {1:(s_{\nrr}'=a) }
      \end{array}
      \right\}
    \end{array}
  \end{equation}
  %
  % From label $a$, each branch of the choreography is identified by a
  % unique label, say $a_1$ for the first branch and $a_2$ for the
  % second. 
  The core idea is that we use reserved variables $s_{\nr}$ and
  $s_{\nrr}$ to track the state of each module, in order to simulate
  the behaviour of the choreography.
  %
  The various steps of the projection can then be summarised as
  follows:
  \begin{enumerate}
  \item We first project \(X^d\), which is annotated with the unique
    identifier \(d\). This generates the commands
    \(\commandBase{d}{s_{\nr}=d}{1:(s_{\nr}'=a)}\) and
    \(\commandBase{d}{s_{\nrr}=d}{1:(s_{\nrr}'=a)}\) for \(\nr\) and
    \(\nrr\), respectively.  Since \(X^d\) is the starting
    choreography, we assume that all PRISM modules initially start in
    a state where the reserved variables satisfy \(s_{\nr}=d\) and
    \(s_{\nrr}=d\).  The intention is that the commands of the two
    modules synchronise on \(d\) and then activate the first action,
    labelled \(a\), in the body of \(X\).
    
  \item Separately, we must project the bodies of all definitions in
    \(\defin\). In our case, we project
    \[
      \interactBasel{\nr}{a}{\nrr}
      \left\{
        \begin{array}{lll}
          \lambda_1 : (x'=1)\ \&\ (y'=2);\ X^b \\[0.5mm]
          \lambda_2 : (x'=3)\ \&\ (y'=1);\ X^c
        \end{array}
      \right.
    \]
    % 
    The first step of the projection ensures that this interaction is
    enabled only when the variables \(s_{\nr}\) and \(s_{\nrr}\) are
    equal to the label \(a\). The operation has two possible outcomes:
    either a synchronisation on label \(a_1\) with rate \(\lambda_1\),
    or a synchronisation on label \(a_2\) with rate \(\lambda_2\).  In
    the first case, both \(s_{\nr}\) and \(s_{\nrr}\) are set to \(b\)
    (since \(\topannotation{\nr}{X^b}=b\)). In the second case, both
    \(s_{\nr}\) and \(s_{\nrr}\) are set to \(c\).
    %
    Thus, each branch is assigned a unique state to ensure that only
    one transition can be taken at a time in the PRISM model. The
    recursive nature of the choreography ensures that the reserved
    variables return to label $a$ after each interaction, allowing the
    process to repeat.
    %
    This is done as in the projection of \(X^d\), linking the flow of
    execution back to a state in which \(s_{\nr}\) and \(s_{\nrr}\)
    are both set again to \(a\).

  \end{enumerate}


  
  % \begin{enumerate}
  % \item \textbf{Computing the States.} Starting from a state where
  %   reserved variable \( s_{\role{p}} = d \) and reserved variable
  %   \( s_{\role{q}} = d \), we apply our projection function to
  %   determine the new state values for each interaction.
  %   % The auxiliary function \(\mathsf{nodes}(C)\) counts the steps
  %   % within each branch of the choreography.
  %   Since each branch in Example \ref{example2} consists of a single
  %   interaction followed by a recursive call to \(C\), the state
  %   updates will be
  %   %
  %   \( s_{\nr}' = b \) and \( s_{\nrr}' = b \)
  %   %
  %   or
  %   %
  %   \( s_{\nr}' = c \) and \( s_{\nrr}' = c \)
  %   % 
  %   depending on the branch.
  %   %
  %   % In particular, for the \(j^{\text{th}}\) branch, the new state is
  %   % given by $ \iota + 1 + \sum_{k=1}^{j-1} \mathsf{nodes}(C_k) $.
  %   % %
  %   % Applying this formula to our example:
  %   % \begin{enumerate}
  %   % \item Branch \(\lambda_1\) (label \(a_1\)):
  %   %   \begin{itemize}
  %   %   \item The initial state is \( s_{\role{p}} = 0 \) and
  %   %     \( s_{\role{q}} = 0 \).
  %   %   \item in the first branch ($j=1$), the sum
  %   %     $\sum_{k=1}^{j-1} \mathsf{nodes}(C_k)$ is equal to $0$,
  %   %     therefore
  %   %     \[
  %   %       s'_{\role{p}} = 0 + 1 = 1, \quad s'_{\role{q}} = 0 + 1 = 1
  %   %     \]
  %   %   \item The update rule for this branch is
  %   %     $s_{\role{p}}' = 1 \quad \& \quad s_{\role{q}}' = 1$
  %   %   \end{itemize}
  %   % \item Branch \(\lambda_2\) (label \(a_2\)):
  %   %   \begin{itemize}
  %   %   \item Again, starting from \( s_{\role{p}} = 0 \) and
  %   %     \( s_{\role{q}} = 0 \).
  %   %   \item in the second branch ($j=2$), the sum
  %   %     $\sum_{k=1}^{j-1} \mathsf{nodes}(C_k)$ is equal to $1$ because
  %   %     the first branch contains only the recursive call to
  %   %     $C$. Hence,
  %   %     \[
  %   %       s'_{\role{p}} = 0 + 2 = 2, \quad s'_{\role{q}} = 0 + 2 = 2
  %   %     \]
  %   %   \item The update rule for this branch is
  %   %     $s_{\role{p}}' = 2\quad\& \quad s_{\role{q}}' = 2$
  %   %   \end{itemize}
  %   % \end{enumerate}
  %   Thus, each branch is assigned a unique state to ensure that only
  %   one transition can be taken at a time in the PRISM model. The
  %   recursive nature of the choreography ensures that the reserved
  %   variables return to $a$ after each interaction, allowing the
  %   process to repeat.

  % \item \textbf{Assigning Unique Labels.}  For each branch, a unique
  %   label is generated from the interaction’s base label. In this
  %   example, the first branch is assigned label \(a_1\) and the second
  %   \(a_2\). These labels serve as synchronisation points between the
  %   interacting modules. In our projection, role \(\role{p}\) (the
  %   initiator) uses the corresponding rates (\(\lambda_1\) and
  %   \(\lambda_2\)) while role \(\role{q}\) uses a fixed rate (equal to
  %   1) for synchronisation.

  % \item \textbf{From Choreography to PRISM.} As detailed in
  %   Example \ref{example3}, the projected PRISM network is obtained by
  %   creating commands for each branch in both roles. Each command is
  %   guarded by a condition on the state counter (for instance,
  %   \(s_{\role p}=0\) for the first branch) and includes the update
  %   that sets the counter to the new state computed above. The modules
  %   for \(\role{p}\) and \(\role{q}\) synchronise on the unique labels
  %   \(a\) and \(b\), and the overall system's global transitions
  %   (e.g. \(F_1\) and \(F_2\)) are derived by the composition of these
  %   synchronised commands. The rates of these transitions are computed
  %   as the product of the individual rates (i.e.,
  %   \(\lambda_i = \mu_i * \gamma_i\)).
  % \end{enumerate}

\end{example}

Note that the projection from Definition~\ref{def:projCTMC} works only
with rates. In the case of probabilities, we must ensure that the
probabilities of a branching sum to~1, which is not guaranteed by
Definition~\ref{def:projCTMC}.
%
This is because we cannot enforce both $\nr$ and
$\{\nr_1,\ldots,\nr_n\}$ to take the same branch according to the
probability distribution given by the \(\lambda_i\)’s. To address this
issue, we introduce the following definition instead:
% 
\begin{definition}[Projection, DTMC]\label{def:projDTMC} Given an
  annotated choreography with probabilities $C$ and a module $\nr$, we
  define $\proj$ as:
  \begin{displaymath}\small
    \begin{array}{lr}
      \proj (\nrr,\interactl{\nr}a{\nr_1,\ldots,\nr_n})= 
      &  \boxed{\text{if }\nrr=\nr}\\[2mm]
      \
      \begin{array}{lll}
        \left\{\commandBase {} {s_{\nrr}\!=\! a_0}{\ \sum_{j\in J}
        \lambda_j: s'_{\nrr}\!=\! a_1}\right\}\quad\cup\\[2mm]
        \left\{\commandBase {a_j} {\ s_{\nrr}\!=\! a_1} {\lambda_j:}
        \ s_{\nrr}'\!=\! \mathsf{top}_{\nrr}(C_j)\ 
        \&\ \projE {u_j}\nrr\right\}_{j\in J}
        \ \ \cup\ \ \bigcup_{j\in J} \proj (\nrr, C_j)
      \end{array}
    \end{array}
  \end{displaymath}
  The other cases of the definition are equivalent to those in
  Definition \ref{def:projCTMC}.
\end{definition}
The fix is immediate: module $\nr$ takes a (probabilistic) internal
decision on the $j^{\text{th}}$ branch and then synchronises on label
$a_j$ with $\{\nr_1,\ldots,\nr_n\}$.

\smallskip

\subsection{Correctness.}
Our projection guarantees a correspondence between the semantics of a
choreography and that of its projection.
%
In order to state this correspondence, we rely on the notions of
\emph{head modules} and \emph{strongly connected} choreographies. The
former identifies the modules involved in the next action of a
choreography:
\begin{definition}[Head Modules]
  The function $\hmodules$ is defined as follows:
  \begin{displaymath}\small
    \begin{array}{rll}
      \hmodules(\interact{\nr}{\nr_1,\ldots,\nr_n})\
      & = \ \{\nr, \nr_1,\dots,\nr_n\}\\[1mm]
      \hmodules(\ifTE {E}{\nr}{C_1}{C_2}) \ & =\ \{\nr\}\\
      \hmodules(X) \ & =\ \hmodules (C)\qquad\qquad(\text{if }
                       X\defrec C\in\defin)\\[1mm]
      \hmodules(\CEnd) \ & =\ \emptyset
    \end{array}
  \end{displaymath}
\end{definition}
Then, the property of strongly connected is defined below.
%
\begin{definition}[Strongly Connected Choreography]
  A choreography $C$ is \emph{strongly connected}, written
  $\sconnected(C)$, if it satisfies the following conditions:
  \begin{displaymath}\small
    \begin{array}{c}
      \infer {
      \sconnected(\interact{\nr}{\nr_1,\ldots,\nr_n})
      } {
      \forall j\in J.\ \sconnected(C_j)\ \land\ \hmodules(C_j)\neq\emptyset\Rightarrow \hmodules(C_j)\cap\{\nr, \nr_1,\dots,\nr_n\}\neq\emptyset
      }      



      \qquad\qquad

      \infer {
      \sconnected(\CEnd)
      } {
      }
      \\\\

      \infer {
      \sconnected(\ifTE {E}{\nr}{C_1}{C_2})
      } {
      \forall j\in \{1,2\}.\ \sconnected(C_j)\ \land\ \hmodules(C_j)
      \neq\emptyset\Rightarrow \nr\in\hmodules(C_j)
      }      

      \qquad\qquad
      \infer {
      \sconnected(X)
      } {
      \sconnected(C)\qquad X\defrec C\in\defin
      % &\text{\marco{is this wrong? Annotate? } }
        }

      \\\\


    \end{array}
  \end{displaymath}
\end{definition}
%
Note that the definition above is coinductive but decidable.  The
notion of connectedness is quite well-known in the literature. Since
our framework is based on synchronous communication, we follow the
same approach as that of Carbone et al.~\cite{CHY12}. The basic idea
is that each interaction shares at least one module with the
subsequent choreography. In particular, in every branch of a
probabilistic choice or an if-then-else involving modules
$\nr_1, \ldots, \nr_n$, the first action (if any) of every other
module $\nrr$ must be an interaction with one of
$\nr_1, \ldots, \nr_n$, possibly after unfolding recursive calls.
%
For example, the choreography $X$, obtained from the definition
\begin{displaymath}\small
  X\defrec
  \interactBase{\nr}{\nrr}:\,
  \left(
    \begin{array}{l}
      \lambda_1: u_1;\ \interactBase{\nrr}{\nrrr}:\, \lambda_1':u_1';\ X    \\
      \lambda_2: u_2;\ X
    \end{array}
  \right)
\end{displaymath}
%
is strongly connected while 
% 
$
\interactBase{\nr}{\nrr}:\,
\left(
  \begin{array}{l}
    \lambda_1: u_1;\ \interactBase{\nrrr_1}{\nrrr_2}:\, \lambda_1':u_1';\ \CEnd.
  \end{array}
\right) $ is not.
% 

%%%%  THIS LEMMA HERE MEANS NOTHING AS IT IS STATED
% Then, we can state the following Lemma which identifies some
% uniqueness properties of projections. 
% \begin{lemma}
%   The state of a projected choreography is uniquely identified by the
%   counter $\iota$.
% \end{lemma}

\smallskip

% We are now ready for our main theorem. In the sequel, $S_+$ is
% obtained from state $S$ by extending its domain with the extra
% variables $s_{\role q}$ (one for each module in a choreography) used
% by the projection.  In the projection, we utilize alphabetised
% parallel composition $\pp$, wherein modules synchronise solely on
% labels that appear in both modules.
We are now ready to state our main theorem, which relates a
(projectable, strongly connected) choreography with its PRISM
projection.  In the sequel, $S_+$ denotes the extension of a global
state $S$ with the additional reserved variables $s_{\nrr}$ (one for
each module $\nrr$), introduced by the projection.  The projection
uses alphabetised parallel composition~$\pp$, where modules
synchronise only on shared labels.
%
\begin{theorem}[Projection]\label{thm:epp}
  Let $C$ be an annotated choreography such that $\sconnected(C)$, and
  let $S_+$ be an extension of a global state $S$ such that for all
  $\nrr\in C$, we have that $S_+(s_{\nrr})=\topannotation\nrr C$.
  Then,
  \[
    (S, C) \red{\lambda} (S', C') \quad\text{if and only if}\quad
    \pp_{\nrr\in C}\ \proj(\nrr, C)\ \vdash\ S_+ \red{\lambda} S_+' ,
  \]
  such that: 
  \begin{itemize}
  \item for all $\nrr\in C$, we have that
    $\proj(\nrr, C') \subseteq \proj(\nrr, C)$
  \item $S'=S'_{+}\backslash \{s_{\nrr}\}_{\nrr\in C}$
  \item for all $\nrr\in C$, we have that
    $S_+'(s_{\nrr}) = \topannotation\nrr {C'}$
  \end{itemize}
\end{theorem}
%
% PROOF
%
\begin{proof}
  The proof proceeds by induction on $C$.
  \begin{itemize}

  \item $C=\interactl{p}a{\nr_1,\ldots,\nr_n}$. By the only
    applicable rule \textsf{(Interact)}, we have
    % 
    \[
      (S, \interact{p}{\nr_1,\ldots,\nr_n}) \red{\lambda_k}
      (S[u_k], C_k).
    \]
    % 
    By definition of projection, we obtain the following PRISM
    commands.  Module \(\nr\) is projected as:
    \[
      \left\{ \commandBase{a_j}{s_{\nr}=a}{\lambda_j:\ s_{\nr}'=
          \mathsf{top}_{\nr}(C_j)\ \&\ \projE{u_j}{\nr}}
      \right\}_{j\in J} \ \cup\ \bigcup_{j\in J} \proj(\nr, C_j).
    \]
    Modules \(\nr_i\) are projected as:
    \[
      \left\{
        \commandBase{a_j}{s_{\nr_i}=a}{1:\ s_{\nr_i}'=
          \mathsf{top}_{\nr_i}(C_j)\ \&\ \projE{u_j}{\nr_i}}
      \right\}_{j\in J}
      \ \cup\ 
      \bigcup_{j\in J} \proj(\nr_i, C_j).
    \]
    % 
    Any other role $\nrr$ is projected as:
    \[
      \bigcup_{j\in J} \proj(\nrr, C_j).
    \]

    We must show two properties: first, that the projection above can
    make the same transition; and second, that if the projection makes
    a transition, it necessarily corresponds to the transition of the
    choreography above.
    % 
    Observe that the state of the generated CTMC is uniquely
    identified by the label \(a\), since Assumption~\ref{ass:1}
    ensures that, for all \(\nrr\), there is no other command whose
    guard satisfies \(s_{\nrr}=a\).

    Therefore, the only-if direction of the theorem follows directly
    by applying rule \textsf{(Interact)}, whose premise is satisfied
    by deriving, via rule \textsf{(P$_2$)}, the command:
    \[
      \begin{array}{l}
        \commandBase{a_k}{(s_{\nr}=a) \land (s_{\nr_1}=a)
        \land \dots \land (s_{\nr_n}=a)}\\[1mm]
        \qquad
        \begin{array}{ll}
          (\lambda_k \cdot 1^n):\ &
                                    (\projE{u_k}{\nr})\ \&\
                                    (\projE{u_k}{\nr_1})\ \&\
                                    \dots\ \&\
                                    (\projE{u_k}{\nr_n})
          \\[1mm]
                                  &\ \&\
                                    (s_{\nr}'=\topannotation{\nr}{C_k})\ \&\
                                    (s_{\nr_1}'=\topannotation{\nr_1}{C_k})\ \&\
                                    \dots\ \&\
                                    (s_{\nr_n}'=\topannotation{\nr_n}{C_k})
        \end{array}
      \end{array}
    \]

    For the converse direction, as far as the modules
    \(\nr, \nr_1, \dots, \nr_n\) are concerned, there can only be a
    synchronisation on the label \(a\). In this case, since no other
    command can synchronise on \(a\), we conclude that the transition
    must arise from the projection of the choreography, which can
    always perform the corresponding step.  It remains to consider the
    case in which a reduction in the projection involves only commands
    on modules different from \(\nr, \nr_1, \dots, \nr_n\). However,
    this case is impossible, since we assume the choreography to be
    strongly connected. As a consequence, any other transition
    involving different modules must be causally dependent on one of
    \(\nr, \nr_1, \dots, \nr_n\).


  \item $C=\ifTEl {E}a{\nr}{C_1}{C_2}$.
      % 
      In this case, the projection of $\nr$ is
      \begin{equation*}
        \quad\left\{ 
          \begin{array}{lll}
            \commandBase {} {s_{\nr}\!=\! a\ \&\ E}{\ 1: s'_{\nr}\!=\!
            \mathsf{top}_{\nr}(C_1)},\\ 
            \commandBase {} {s_{\nr}\!=\! a\ \&\ \mathsf{not}(E)}
            {\ 1: s'_{\nr}\!=\! \mathsf{top}_{\nr}(C_2)}
          \end{array}
        \right\}
        \ \cup\ \proj (\nr, C_1)
        \ \cup\
        \proj (\nr, C_2)
      \end{equation*}
      while, for all other modules, we have
      $ \proj (\nrr, C_1) \ \cup\ \proj (\nrr, C_2) $.  In this case,
      module $\nr$ is enabled by the uniqueness of $a$, while all
      other modules are not simply because we assume that the
      choreography is strongly connected. Hence, any other
      synchronisation or if-then-else statement is blocked, as it must
      involve $\nr$.
      

    \item $C=X^a$. By definition, assuming $X\defrec C_X\in \defin$,
      it must be the case that, for all $\nrr\in C$:
    \[\proj (\nrr, X^a) = \{ \commandBase {a} {s_{\nrr}\!=\! a}{\ 1:
        s'_{\nrr}\!=\! }
      \mathsf{top}_{\nrr}(C)\}\qquad\cup\quad\bigcup_{(Y\defrec
        C_Y)\in\defin}\big(\proj (\nrr, C_Y)\big)\]
    %
    We now show both directions.
    \begin{itemize}
    \item (only if). Here, we know that $(S, X^a) \red{1} (S,
      C_X)$. From the uniqueness of $a$, we can derive
      $\pp_{\nrr\in C}\ \proj(\nrr, C)\ \vdash\ S_+ \red{\lambda}
      S_+'$ by applying rule (\textsf{M}) on each module, then rule
      (\textsf{P$_2$}), and finally rule (\textsf{Transition}).
      % 
      Moreover, we observe that the command
      $s'_{\nrr}\!=\!  \mathsf{top}_{\nrr}(C)$ has no effect on the
      state except modifying the extended variables with the top
      annotation in $C$ which, by assumption again, it is
      unique. Additionally, we observe that for all $\nrr\in C$, we
      have that $\proj(\nrr, C') \subseteq \proj(\nrr, C)$. Finally,
      for all $\nrr\in C$, we have that
      $S_+'(s_{\nrr}) = \topannotation\nrr {C'}$.

    \item (if). In this direction, we just observe that, for all
      $\nrr$, the extended state variables $s_{\nrr}$ are all set to
      $a$. Therefore, given uniqueness of annotations, the projected
      modules can only simulate the procedure call.

    \end{itemize}

  \item $C=\CEnd^a$. Immediate. 
    
  \end{itemize}
        The case for DTMC is also similar.

     
\end{proof}
We observe that the theorem departs from standard projection results
for choreography languages.  In most settings, both choreographies and
endpoints are expressed in a process algebra in which control flow is
encoded syntactically, and correctness is shown by relating reductions
of programs.  PRISM, instead, is declarative: a module consists of a
fixed set of commands, and execution is driven solely by state changes
through the enabling of commands.
%
Our choreography language combines both aspects.  Although it
maintains an explicit runtime state for variables, its syntax
determines the next action to be executed.  The projection reconciles
this mismatch by encoding control-flow information into the state: the
variables $s_{\nrr}$ act as a distributed program counter, yielding
the extended state $S_+$.
%
Consequently, choreography reduction corresponds in the projection to
transitions on $S_+$ rather than to syntactic changes of PRISM
modules.  
% Our main theorem shows that this asymmetry is benign: the observable
% behaviour of the projected model is completely determined by the
% evolution of the extended state $S_+$, which faithfully captures
% choreography execution.
%




\begin{remark}
  %
  Our theorem induces an asymmetry: reducing a choreography before
  projection may result in fewer commands than projecting first,
  whereas PRISM execution never alters the set of commands.  Let us
  focus on an example where we compare the semantics of the
  choreography \(X^d\), obtained from the recursive definition in
  Example~\ref{example2}, with that of its projection from
  Example~\ref{example-proj}. Starting from a state \(S_0\) in which
  \(x=0\) and \(y=0\), and from its extension \(S_0^+\), where
  additionally \(s_{\nr}=d\) and \(s_{\nrr}=d\), both the choreography
  and its projection from Equation~\ref{eq:1} have a single possible
  transition:
  \begin{displaymath}
    \begin{array}{lll}
      (S_0,\ X^d)\red 1
      \left(S_0,\ \interactBasel{\nr}{a}{\nrr}
      \left\{
      \begin{array}{lll}
        \lambda_1 : (x'=1)\ \&\ (y'=2);\ X^b \\[0.5mm]
        \lambda_2 : (x'=3)\ \&\ (y'=1);\ X^c
      \end{array}
      \right.\right)
      \\\\
      \pp_{\nrrr\in X^d}\ \proj (\nrrr, X^d)\vdash S_{+}
      \red{\lambda} S_{+}[s_{\nr}'=a][s_{\nrr}'=a]
    \end{array}
  \end{displaymath}
  Clearly, the projection of the unfolding of \(X^d\) is still
  contained in the projection of \(X^d\). This is because the
  interaction \(\interactBasel{\nr}{a}{\nrr}\{\dots\}\) is projected
  twice: once when projecting the reductum, and once when projecting
  the definition of \(X\). On the other hand, the commands
  \(\commandBase{d}{s_{\nr}=d}{1:(s_{\nr}'=a)}\) and
  \(\commandBase{d}{s_{\nrr}=d}{1:(s_{\nrr}'=a)}\) are no longer
  generated.

  In an attempt to correctly annotate the resulting choreography,
  while avoiding name clashes with the recursive definitions, we would
  obtain the choreography
  \[
    \left(S_0,\ \interactBasel{\nr}{a'}{\nrr}
      \left\{
        \begin{array}{lll}
          \lambda_1 : (x'=1)\ \&\ (y'=2);\ X^{b'} \\[0.5mm]
          \lambda_2 : (x'=3)\ \&\ (y'=1);\ X^{c'}
        \end{array}
      \right.\right)
  \]
  and its projection (which we denote by \(N\)):
  \begin{displaymath}
    \small
    \begin{array}{llll}
      \role{p}: \left\{
      \begin{array}{lll}
        \commandBase{a_1'}{s_{\nr}=a'}{\lambda_1:(x'=1)\ \&\ (s_{\nr}'=b')},
        & \quad \commandBase{b'}{s_{\nr}=b'}{1:(s_{\nr}'=a)},\\
        \commandBase{a_2'}{s_{\nr}=a'}{\lambda_2:(x'=3)\ \&\ (s_{\nr}'=c')},
        & \quad \commandBase{c'}{s_{\role p}=c'}{1:(s_{\role p}'=a)}
        \\
        \commandBase{a_1}{s_{\nr}=a}{\lambda_1:(x'=1)\ \&\ (s_{\nr}'=b)},
        & \quad \commandBase{b}{s_{\nr}=b}{1:(s_{\nr}'=a)},\\
        \commandBase{a_2}{s_{\nr}=a}{\lambda_2:(x'=3)\ \&\ (s_{\nr}'=c)},
        & \quad \commandBase{c}{s_{\role p}=c}{1:(s_{\role p}'=a)}
      \end{array}
      \right\}
      \\[1cm]
      \role{q}: \left\{
      \begin{array}{lll}
        \commandBase{a_1'}{s_{\role q}=a'}{1:(y'=2)\ \&\ (s_{\role q}'=b')},
        & \quad \commandBase{b'}{s_{\role q}=b'}{1:(s_{\role q}'=a)}, \\
        \commandBase{a_2'}{s_{\role q}=a'}{1:(y'=1)\ \&\ (s_{\role q}'=c')},
        & \quad \commandBase{c'}{s_{\role q}=c'}{1:(s_{\role q}'=a)}
        \\
        \commandBase{a_1}{s_{\role q}=a}{1:(y'=2)\ \&\ (s_{\role q}'=b)},
        & \quad \commandBase{b}{s_{\role q}=b}{1:(s_{\role q}'=a)}, \\
        \commandBase{a_2}{s_{\role q}=a}{1:(y'=1)\ \&\ (s_{\role q}'=c)},
        & \quad \commandBase{c}{s_{\role q}=c}{1:(s_{\role q}'=a)}
      \end{array}
      \right\}
    \end{array}
  \end{displaymath}
  We observe that the PRISM model obtained by projecting the reductum
  \(\interactBasel{\nr}{a}{\nrr}\{\dots\}\), starting from the state
  \(S_{+}[s_{\nr}'=a][s_{\nrr}'=a]\), exhibits the same behaviour as
  the model \(N\) starting from the state
  \(S_{+}[s_{\nr}'=a'][s_{\nrr}'=a']\).  Relating these two states
  would require a suitable notion of equivalence induced by the
  semantics of PRISM, which we leave as future work. We conjecture
  that, under an appropriate equivalence notion, such as probabilistic
  bisimulation, our theorem could be extended to capture this
  additional feature.
\end{remark}



%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "main"
%%% End:
