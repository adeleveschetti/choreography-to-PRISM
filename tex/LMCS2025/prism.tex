We now give a formal definition of a fragment of the PRISM language by
introducing its formal syntax and semantics.

\subsection{Syntax.} We reuse some of the syntactic terms used for our
choreography language, including assignments and expressions. In the
sequel, let $a$ range over a (possibly infinite) set of labels
$\mathcal L$. We define the syntax of (a subset of) the PRISM language
as follows:
\begin{displaymath}
  \begin{array}{lrlll@{\qquad}l}
    \text{(Networks)}  \quad
    & N, M  & ::=  &      & \CEnd & \text{empty network}\\[1mm]
    &       &      & \mid & \role{p}:\{F_i\}_i & \text{module}\\[1mm]
%    &       &      & \mid & M \pp M    & \text{parallel composition}\\
    &       &      & \mid & M \ppp A M & \text{parallel composition}\\
    % &       &      & \mid & M/A        & \text{action hiding}\\
    % &       &      & \mid & \sigma M   & \text{substitution}\\
    \\
    \text{(Commands)}  \quad
    & F     & ::=  &      & \command \alpha g\lambda u
                                  & \text{} (\alpha\in\{\epsilon\}\cup\mathcal L) \\
    % \\[1mm]
    % \text{(Assignment)} \quad
    % & u     & ::=  &      & (x' = E) & \text{update $x$ % , element of $\mathcal V$, 
    %                                    with $E$}\\
    % &       &      & \mid & u\ \&\ u   & \text{multiple assignments}
    % \\[1mm]
    % \text{(Expr)}\quad
    % & E, g     & ::= &       & f(\tilde E)\quad\mid\quad x\quad\mid\quad v & \text{expressions}
    % % \\[1mm]
    % % \text{(Rates)}\quad   &     \lambda\in\mathbb R
    % %  \\[1mm]
    % %   \text{(Variables)}\quad &   x\in\mathsf{Var} 
    % %  \\[1mm]
    % %   \text{(Values)}\quad     &  v\in\mathsf{Val} 
  \end{array}
\end{displaymath}
Networks are the top syntactic category for system of modules composed
together. The term $\CEnd$ represent an empty network. A module is
meant to represent a process running in the system and is denoted by
its name and its commands, formally written as $\role{p}:\{F_i\}_i$,
where $\role p$ is the name and the $F_i$'s are commands. Networks can
be composed in parallel, in a CSP style: a term like $M_1 \ppp A M_2$
says that networks $M_1$ and $M_2$ can synchronise using labels in the
finite set $A$.
%
In this work, we omit PRISM's hiding and substitution constructs as
they are irrelevant for our current choreography language.
% The term $M/A$ is the standard CSP/CCS hiding operator. Finally
% $\sigma M$ is equivalent to applying the substitution $\sigma$ to
% all variables in $x$. A substitution is a function that given a
% variable returns a value. When we write $\sigma N$ we refer to the
% term obtained by replacing every free variable $x$ in $N$ with
% $\sigma(x)$. \marco{Is this really the way substitution is used?
% Where does it become important?}
%
Commands in a module have the form
$[\alpha] g \rightarrow \Sigma_{i\in I}\{\lambda_i: u_i\}$. The
character $\alpha$ can either be the empty string $\epsilon$ or a
label $a$, i.e., $\alpha\in\{\epsilon\}\cup \mathcal L$. If $\epsilon$
then no synchronisation is required. On the other hand, if there is
label $a$ then there will be a synchronisation with other modules that
must synchronise on $a$. The term $g$ is a guard on the current
variable state. If both label and guard are enabled, then the command
executes a branch $i$ with probability/rate $\lambda_i$. As for
choreographies, if the $\lambda_i$'s are probabilities, we must have
that $0\leq\lambda_i\leq 1$ and $\Sigma_{i\in I}\lambda_i=1$.

\subsection{Semantics.} To give a probabilistic semantics to the PRISM
language, we follow the approach given in the PRISM
documentation~\cite{PRISMdoc}.  Hereby, we do that by defining two
relations: one with labels for networks and one on states. Our
relation on networks is the smallest relation $\prismred{}{}$
satisfying the rules given in Fig.~\ref{fig:semantics}.
% 
\begin{figure}[h]
  \begin{displaymath}\small
    \begin{array}{ccc}
      \infer[\mathsf{(M)}]
      { {\role{p}:\{F_k\}_k} \prismred{} F
      % {\alpha}\lab{g}{\Sigma_{i\in I}\lambda_i\!}{u_i} 
      }
      {
      % \command {\alpha}g\lambda u
      F\in\{F_k\}_k
      }
      \quad
      \infer[\mathsf{(P_1)}]
      {M_1\ppp A M_2\prismred{}\command {\alpha}g\lambda u
      % {\alpha}\lab{g}{\Sigma_{i\in I}\lambda_i\!}{u_i}
      }
      {
      \exists j\in\{1,\!2\}.\ 
      M_j\prismred{} \command {\alpha}g\lambda u
      % {\alpha}\lab{g}{\Sigma_{i\in I}\lambda_i\!}{u_i}
      & \alpha\!\not\in\! A
        }
      \\\\
      \infer[\mathsf{(P_2)}]
      {M_1\ppp A M_2\prismred{}
      \commandBase a{g\land g'}
      {\Sigma_{i,j}\,\lambda_i*\lambda'_j}: {u_i\& u'_j} 
      }
      {
      M_1\prismred{}\command {a}g\lambda u
      % {a}\lab{g}{\Sigma_{i\in I}\lambda_i}{\!u_i} 
      \quad&\quad 
        M_2\prismred{}\commandBase {a} {g'} \Sigma_{j\in J}\lambda'_j: u'_j
        % {a}\lab{g'}{\Sigma_{j\in J}\lambda'_j}{\!u'_j} 
      \ &\
             a\!\in\! A}
    \end{array}
  \end{displaymath}
  \caption{Semantics for PRISM networks} 
  \label{fig:semantics}
\end{figure}
Rule $\mathsf{(M)}$ just exposes a command at network level. Rule
$\mathsf{(P_1)}$ propagates a command through parallel composition if
$\alpha$ is empty or if the label $a$ is not part of the set $A$. When
the label $a$ is in $A$, we apply rule $\mathsf{(P_2)}$. In this case,
the product of the probabilities/rates must be taken by extending the
two different branches to every possible combination. This also
includes the combination of the associated assignments.

Based on the relation above, given
$M\prismred{}\command \alpha g\lambda u$ and two
states $S$ and $S'$, we define the function
$$\mu(\command \alpha g\lambda u,\ S,\ S'\ ) = \Sigma_{S[u_i]=S',i\in I}\lambda_i$$
which gives the probability/rate for the system to go from state $S$
to state $S'$ after executing command $\command \alpha g \lambda u$,
for some $\alpha$.
%
If the $\lambda_i$ are probabilities, then the function must be a
probability distribution. Note that $\mu(F,S,S')$ only denotes the
probability/rate for the system to move from state $S$ to state $S'$
after executing command $F$. However, there can be other commands
derived from a given network $M$ through the relation $\prismred{}$
that would cause a transition from $S$ to $S'$. Therefore, we define
the transition relation on states $M\vdash S\red{\lambda}S'$ as
$$
\infer[\mathsf{(Transition)}]
{
  M\vdash S\red{\sum_{j} \mu(F_j,S,S')}S'
  % M\vdash S\red{\sum_{S'= S[u_j]} \lambda_j}S'
}
{
  \forall j,\alpha.\ M\prismred{}F_j
  % \command{\alpha_j} {g_j}{{\lambda_j}} {{u_j}}
  \quad&\quad
  S\vdash F_j
}
$$
where $S\vdash \command \alpha g\lambda u$ is defined as $\eval gS$.
Note that since PRISM is declarative, a term $M$ never changes while
the state of the system evolves.

It is important to point out that, in general, the transition rule
above does not give the exact probability of a transition in case of a
Markov chain (DTMC), since the sum ${\sum_{j} \mu(F_j,S,S')}$ could be
a value greater than $1$. In order to get the right probability, the
value has to be normalised for all reachable $S'$. In the next
section, we will show that this is not an issue for networks that are
obtained from our translation from choreography to PRISM.

\begin{example}
  Consider the following network $M$:
  \begin{displaymath}
    \begin{array}{llll}
      \role{p}: \{ & \quad \commandBase {}{x=0} {1:(x'=1)}\\
                   & \quad \commandBase {a}{y<1} {0.4: (x'=x+1)\ +\ 0.6: (x'=x)}\quad \}\\[2mm]
      \role{q}: \{ & \quad \commandBase {}{y=0} {1:(y'=1)}\\
                   & \quad \commandBase {a}{x<1} {0.5: (y'=y+1)\ +\ 0.5: (y'=y)}\quad \}\\
    \end{array}
  \end{displaymath}
  above, the two modules $\role p$ and $\role q$ can both do
  independent actions, as well as synchronising on label $a$. Applying
  the semantics, we can easily derive
  $M\prismred{}\commandBase {}{x=0} {1:(x'=1)}$,
  $M\prismred{}\commandBase {}{y=0} {1:(y'=1)}$, and $M\prismred{}F$,
  such that
  \begin{displaymath}\small
    \begin{array}{rlll}
      F=\commandBase {a}{x<1\ \&\ y<1} {\quad} & 0.2: (x'=x+1)\ \&\ (y'=y+1)\\
                                       + & 0.2: (x'=x+1)\ \&\ (y'=y)\\
                                       + & 0.3: (x'=x)\ \&\ (y'=y+1)\\
                                       + & 0.3: (x'=x)\ \&\ (y'=y)\\
    \end{array}
  \end{displaymath}  
  Let $S_0$, $S_1$, $S_2$, and $S_3$ be all possible reachable states
  such that
  %
  $S_0(x)=S_0(y)=0$, $S_1(x)=1$, $S_1(y)=0$, $S_2(x)=0$, $S_2(y)=1$,
  and $S_3(x)=S_3(y)=1$.
  %
  Moreover, let $S_0$ be the starting state. Then, %, we have: % that:
  \begin{displaymath}
    \begin{array}{ll}
      \mu(\commandBase {}{x=0} {1:(x'=1)}, S_0, S_1) = 1
      & \quad \mu(\commandBase {}{x=0} {1:(x'=1)}, S_2, S_3) = 1\\
      \mu(\commandBase {}{y=0} {1:(y'=1)}, S_0, S_2) = 1
      & \quad \mu(\commandBase {}{y=0} {1:(y'=1)}, S_1, S_3) = 1\\ 
      \mu(F, S_0, S_1) = 0.2 &\quad\mu(F, S_0, S_2) = 0.3\\
      \mu(F, S_0, S_0) = 0.3 & \quad\mu(F, S_0, S_3) = 0.2\\
    \end{array}
  \end{displaymath}  
  Now, by rule $\textsf{(Transition)}$ above, we have that
  $M\vdash S_0\rightarrow_{1.2} S_1$,
  $M\vdash S_0\rightarrow_{1.3} S_2$,
  $M\vdash S_0\rightarrow_{0.2} S_3$, and
  $M\vdash S_0\rightarrow_{0.3} S_0$. Clearly, both transitions should
  be normalised, finally yielding the following DTMC:
  %
  \begin{center}
    \begin{tikzpicture}[
      scale=0.8,
      transform shape,
      node distance=0.4cm and 3cm,
      conf/.style={
        draw, circle,
        align=center,
        font=\scriptsize,
        inner sep=1.5pt
      },
      ->, >=stealth
      ]

      % States (stores only)
      \node[conf] (S0) {$
        \begin{array}{c}
          S_0
        \end{array}$};

      \node[conf] (S1) [above right=of S0] {$
        \begin{array}{c}
          S_1
        \end{array}$};

      \node[conf] (S2) [below right=of S0] {$
        \begin{array}{c}
          S_2
        \end{array}$};
      
      \node[conf] (S3) [below right=of S1] {$
        \begin{array}{c}
          S_3
        \end{array}$};

      % Incoming arrow
      % \draw[->] ([xshift=-1.2cm]S0.west) --  (S0.west);
      
      % Probabilistic transitions from S0
      \draw (S0) edge[loop above] node{$0.1$} (S0);
      \draw[bend left=30](S0) to node[above] {$0.4$} (S1);
      \draw[bend right=30] (S0) to node[below] {$0.43$} (S2);
      \draw (S0) to node[above right] {$0.07$} (S3);
      
      % Deterministic transitions
      \draw[bend left=30] (S1) to node[above] {$1$} (S3);
      \draw[bend right=30] (S2) to node[below] {$1$} (S3);
      
    \end{tikzpicture}
  \end{center}
\end{example}


%% NEW VERSION







\begin{example}\label{example3}
  The choreography presented in Example \ref{example2} can be
  described by the following PRISM network $M$ (for
  $\lambda_i=\mu_i*\gamma_i$):
\begin{displaymath}\small
  \begin{array}{llll}
    \role{p}: \{ & \quad \commandBase {a}{s_{\role p}=0} {\mu_1:(x'=1)
                   \ \&\ (s_{\role p}'=1)} 
                   \quad\qquad \commandBase {}{s_{\role p}=1} 
                   {1:(s_{\role p}'=0) }\\
                 & \quad \commandBase {b}{s_{\role p}=0} {\mu_2:(x'=3)
                   \ \&\ (s_{\role p}'=2)}
                   \quad\qquad \commandBase {}{s_{\role p}=2} 
                   {1:(s_{\role p}'=0) }\quad \}\\[2mm]
    \role{q}: \{ & \quad \commandBase {a}{s_{\role q}=0} {\gamma_1:(y'=2)
                   \ \&\ (s_{\role q}'=1) } 
                   \qquad\quad \commandBase {}{s_{\role q}=1} 
                   {1:(s_{\role q}'=0) }\\
                 & \quad \commandBase {b}{s_{\role q}=0} {\gamma_2:(y'=1)
                   \ \&\ (s_{\role q}'=2) } 
                   \qquad\quad \commandBase {}{s_{\role q}=2} 
                   {1:(s_{\role q}'=0) }\quad \}\\
  \end{array}
\end{displaymath}
The two modules $\role p$ and $\role q$ synchornize on the labels $a$
and $b$.  Applying the semantics, the global state can evolve
according to $F_1$ or $F_2$, defined as follows:
\begin{displaymath}\small
  \begin{array}{rlll}
    F_1=\commandBase {a}{s_{\role p}=0\ \&\ s_{\role q}=0} {\quad} \mu_1*\gamma_1 : 
    (x'=1) \ \&\ (y'=2) \ \&\ (s_{\role p}'=1) \ \&\ (s_{\role q}'=1) \\
    F_2=\commandBase {b}{s_{\role p}=0\ \&\ s_{\role q}=0} {\quad} \mu_2*\gamma_2 : 
    (x'=3) \ \&\ (y'=1) \ \&\  (s_{\role p}'=2) \ \&\ (s_{\role q}'=2)\\

  \end{array}
\end{displaymath} 

\end{example}

% SEMANTICS WITH GUESS (Early)
%
% \begin{figure}[t]
%   \begin{displaymath}\small
%     \begin{array}{ccc}
%       \infer[\mathsf{(M_1)}]
%       { {\role{p}:\{F_k\}_k} \prismred{}\lab{g}{\lambda_i}{u_i} }
%       {\command {}g\lambda u\in\{F_k\}_k}
%       \qquad
%       \infer[\mathsf{(P_1)}]
%       {M_1\ppp A M_2\prismred{\alpha}\lab g\lambda u }
%       {
%       \exists j\in\{1,2\}.\ 
%       M_j\prismred{\alpha}\lab g\lambda u
%       & \alpha\not\in A
%         }
%       \\\\
%       \infer[\mathsf{(M_2)}]
%       { {\role{p}:\{F_k\}_k} \prismred{a}\lab{g}{\lambda_i\!\!}{u_i} }
%       {\command ag\lambda u\in\{F_k\}_k}
%       \quad
%       \infer[\mathsf{(P_2)}]
%       {M_1\ppp A M_2\prismred{a}\lab{g_1\land g_2}{\lambda_1*\lambda_2\!\!}{u_1\& u_2} }
%       {
%       M_1\!\!\!\prismred{a}\!\!\!\lab{g_1}{\lambda_1\!\!}{\!\!u_1} 
%       & M_2\!\!\!\prismred{a}\!\!\!\lab{g_2}{\lambda_2\!\!}{\!\!u_2} 
%       & a\!\in\! A}
%     \end{array}
%   \end{displaymath}
%   \caption{LTS for PRISM networks} 
%   \label{fig:semantics}
% \end{figure}

%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "main"
%%% End:
