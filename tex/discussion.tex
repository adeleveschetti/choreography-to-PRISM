%
\mypar{Related Work.}  Choreographic programming~\cite{M23} is a
language paradigm for specifying the expected interactions
(communications) of a distributed system from a global viewpoint,
from which decentralised implementations can be generated via
projection. The notion of choreography has been substantially explored
in the last decade, both from a theoretical perspective,
e.g.,~\cite{CHY12,CM13}, to full integration into fully-fledged
programming languages, such as WS-CDL~\cite{HYC07b} and
Choral~\cite{GMP24}. Nevertheless, there is a scarcity of research on
probabilistic aspects of choreographic programming.
%
To the best of our knowledge, Aman and Ciobanu~\cite{AC19,AC22} are
the only ones who studied the concept of choreography and
probabilities. Their work augments multiparty session types (type
abstractions for communicating systems that use the concept of
choreography) with a probabilistic internal choice similar to the one
used by our choreographic branching. However, they do not provide any
semantics with state in terms of Markov chains, and, most importantly,
they do not project into a probabilistic declarative language model
such as PRISM.
%
Carbone et al.~\cite{CGHL10} define a logic for expressing properties
of a session-typed choreography language. However, the logic is
undecidable and has no model-checking algorithm. % More recently,
% Cruz-Filipe et al.~\cite{CGMP23}
%
As far as our knowledge extends, there is currently no work that
generates probabilistic models from choreographic languages that can
be then model-checked.
% However, the concept of synthesizing local participant specifications
% in accordance with choreographies has been a prominent research focus
% for over two decades. Research in this domain commonly relies on
% abstractions rooted in automata or process calculi
% \cite{DBLP:conf/popl/HondaYC08,DBLP:journals/scp/AutiliIT18}.  Earlier
% implementations of choreographic programming include Chor
% \cite{DBLP:conf/popl/CarboneM13} and AIOCJ
% \cite{DBLP:journals/corr/PredaGGLM16} both of which are grounded in
% process calculi and capable of generating executable Jolie code.



\mypar{Discussion and Future Work.}
% In this section, we discuss the choices made in the development of the choreographic language for modeling and analyzing concurrent probabilistic systems as presented in this paper. 
%
The general goal of the proposed framework based on the concept of
choreographic programming is to improve several aspects, including
usability, correctness, and efficiency in modeling and analyzing such
systems.
%
The decision to introduce a choreographic language for modelling
processes for PRISM is based on the need to improve the usability of
the model checker. Its language, while very powerful, can be complex
and daunting for users, particularly those without a strong background
in formal methods.

Our choreographic language aims to improve the intuitive modeling of concurrent probabilistic systems. Traditional modeling languages often lack the expressive clarity needed to effectively capture the intricacies of such systems. By designing a language specific for choreographing system behaviors, we provide practitioners with an intuitive means of specifying system dynamics. This approach enables a more natural and straightforward modeling process, essential for accurately representing real-world systems and ensuring the efficacy of subsequent analysis.
%
The choreographic language and projection function aim to abstract
away low-level details and provide a higher-level representation of
system behaviors. 
% However, while this abstraction facilitates intuitive modeling, it
% also introduces the risk of oversimplification. Certain aspects in
% the behavior of concurrent probabilistic systems may be lost during
% the abstraction process, potentially leading to inaccuracies in the
% analysis results [REALLY?  WHAT IS THIS?].
However, a choreographic approach can have some limitations in
expressivity. Some of the case studies presented in the PRISM
documentation~\cite{PRISMdoc} cannot be modeled by using our
language. Specifically, there are two main cases where our approach
encounters limitations:
%
\textit{(i)} in the asynchronous leader election case study, our language prohibits the use of an 'if-then' statement without an accompanying 'else' to prevent deadlocked states; 
%
\textit{(ii)} in probabilistic broadcast protocols or cyclic server polling system models, the system requires probabilistic branching to synchronize different modules based on the selected branch.
%
% \begin{itemize}
% \item \textit{(i)} In the context of asynchronous leader election,
%   processes synchronize with the same label but under different
%   conditions. Our choreographic language includes the "if-then-else"
%   statement but disallows the "if-then" statement without an
%   accompanying "else." This design choice prevents deadlock states
%   from occurring.
% \item \textit{(ii)} Similarly, in probabilistic broadcast protocols,
%   the issue lies in the labels of synchronizations. Here, all
%   processes synchronize with the same label for every action. However,
%   our language prohibits this behavior, as each label must be unique
%   for every synchronization between two or more processes.
% \item \textit{(iii)} In the cyclic server polling system model, the
%   processes "station$_i$" perform two distinct actions in the same
%   state. Specifically, at state 0 ("s$_i$=0"), processes may either
%   synchronize with the "server" process or transition to a different
%   state without synchronization. Our language cannot express this
%   scenario, as synchronization is treated as a branch action,
%   necessitating an alternative option with synchronization.
% \end{itemize}
These issues could be fixed by extending our choreographic language
further and are therefore left as future work.

In conclusion, this paper has introduced a unified framework addressing the challenges of modeling and analyzing concurrent probabilistic systems. By presenting a simplified semantics for PRISM, we enhance the platform's usability. Furthermore, the development of a choreographic language with tailored syntax and semantics offers an intuitive modeling approach. We have established the correctness of a projection function that translates choreographic models to PRISM-compatible formats. Additionally, our compiler enables seamless translation of choreographic models to PRISM, facilitating powerful analysis while maintaining expressive clarity. These contributions bridge the gap between high-level modeling and robust analysis in probabilistic systems, paving the way for advancements in the field. Future work could involve directly projecting choreographic models onto a CTMC or a DTMC, enhancing their versatility and applicability in probabilistic system analysis. However, it remains unclear if a choreographic program can impact the performance of the model checker.

%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "main"
%%% End:
