preamble

"ctmc"

"const k;"
"const T=k*1000;"

"const double rb ;"
"const double mR = 1/600;"
"const double lR = 1-mR;"

"const double hR_1 = 0.33;"
"const double hR_2 = 0.33;"
"const double hR_3 = 0.33;"

"const int N = 100;"

endpreamble

Hasher_i -> Hasher1; Hasher2; Hasher3; 

Miner_i -> 
Miner1 : "b_1 : block {m_1,0;genesis,0};", "B_1 : blockchain [{genesis,0;genesis,0}];", "c_1 : [0..N] init 0;", "setMiner_1 : list [];";
Miner2 : "b_2 : block {m_2,0;genesis,0};", "B_2 : blockchain [{genesis,0;genesis,0}];", "c_2 : [0..N] init 0;", "setMiner_2 : list [];";
Miner3 : "b_3 : block {m_3,0;genesis,0};", "B_3 : blockchain [{genesis,0;genesis,0}];", "c_3 : [0..N] init 0;", "setMiner_3 : list [];";

Network ->
Network : "set_1 : list [];", "set_2 : list [];", "set_3 : list [];"; 
	

PoW := Hasher_i -> Miner_i
(+[mR*hR_i] "&&(b_i'=createB(b_i,B_i,c_i))&(c_i'=c_i+1)" : 
			Miner_i -> Network :[rB] "(B_i'=addBlock(B_i,b_i))&&" foreach(Miner_k != Miner_i) "set_k'=addBlockSet(set_k,b_i)" @Network .PoW
 +[lR*hR_i] "&&" : 
  if "!isEmpty(set_i)"@Miner_i then { 
  		{"(b_i'=extractBlock(set_i))"}@Miner_i . Miner_i -> Network : "(setMiner_i' = addBlockSet(setMiner_i , b_i))&&(set_i' = removeBlock(set_i,b_i))" . PoW 
 }
 else { 
 	if "isEmpty(setMiner_i)"@Miner_i then{			
 			PoW
 	}
 	else{
 		if "canBeInserted(B_i,b_i)"@Miner_i then { 
 					{"(B_i'=addBlock(B_i,b_i))&(setMiner_i'=removeBlock(setMiner_i,b_i))"}@Miner_i . Pow 
 		}
 		else{
 				PoW
 		}
 }
})
	