preamble

"ctmc"

"const k;"
"const T=k*1000;"

"const double rb ;"
"const double mR = 1/600;"
"const double lR = 1-mR;"

"const double hR_1 = 0.33;"
"const double hR_2 = 0.33;"
"const double hR_3 = 0.33;"

"const int N = 100;"

endpreamble

n = 3;

Hasher[i] -> i in [1...n] ;

Miner[i] -> i in [1...n]
Miner[i] : "b[i] : block {m[i],0;genesis,0} ;", "b[i] : blockchain [{genesis,0;genesis,0}];" ,"c[i] : [0..N] init 0;", "setMiner[i] : list [];" ;

Network ->
Network : "set1 : list [];", "set2 : list [];", "set3 : list [];"; 
	

PoW := Hasher[i] -> Miner[i]
(+[mR*hRi] " "&&"(b[i]'=createB(b[i],B[i],c[i]))&(c[i]'=c[i]+1)" : 
			Miner[i] -> Network :[rB] "(B[i]'=addBlock(B[i],b[i]))" foreach(k != i) "set[k]'=addBlockSet(set[k],b[i])" @Network .PoW
 +[lR*hRi] " " : 
  if "!isEmpty(set[i])"@Miner_i then { 
  		{"(b[i]'=extractBlock(set[i]))"}@Miner[i] . Miner[i] -> Network : "(setMiner[i]' = addBlockSet(setMiner[i] , b[i]))"&&"(set[i]' = removeBlock(set[i],b[i]))" . PoW 
 }
 else { 
 	if "isEmpty(setMiner[i])"@Miner_i then{			
 			PoW
 	}
 	else{
 		if "canBeInserted(B[i],b[i])"@Miner[i] then { 
 					{"(B[i]'=addBlock(B[i],b[i]))&(setMiner[i]'=removeBlock(setMiner[i],b[i]))"}@Miner[i] . Pow 
 		}
 		else{
 				PoW
 		}
 }
})
	