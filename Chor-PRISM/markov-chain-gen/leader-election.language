
preamble
"dtmc"

"const N = 4;"
"const K = 3;"
"const L;"
endpreamble

n = 4;

Process[i] -> i in [1...n]
Process[i] : "p[i] : [0..K-1] init 0;", "v[i] : [0..K-1] init 0;", "u[i] : bool;" ;

Counter ->
Counter : "c : [0..N-1] init 0;" ;

{

Election := allSynch{ j in [1...4]
                            Process[j] : (true -> "1/K" : "(p[i]'=0)&(v[i]'=0)&(u[i]'=true)"  + "1/K" : "(p[i]'=1)&(v[i]'=1)&(u[i]'=true)" + "1/K" : "(p[i]'=2)&(v[i]'=2)&(u[i]'=true)"  + "1/K" : "(p[i]'=2)&(v[i]'=3)&(u[i]'=true)"
                             + "1/K" : "(p[i]'=2)&(v[i]'=4)&(u[i]'=true)"  + "1/K" : "(p[i]'=2)&(v[i]'=5)&(u[i]'=true)"  + "1/K" : "(p[i]'=2)&(v[i]'=6)&(u[i]'=true)"  + "1/K" : "(p[i]'=2)&(v[i]'=7)&(u[i]'=true)")
                     } . allSynch{
                        Counter : ("(c<N-1)" -> "1" : "(c'=c+1)")
                        Counter : ("(c=N-1)" -> "1" : "(c'=c)")

                        Process1 : ("u1&!(p1=2)&(c<N-1)" -> "1" : "(u1'=true)&(v1'=v2)")
                        Process1 : ("u1&(p1=2)&(c<N-1)" -> "1" : "(u1'=false)&(v1'=v2)&(p1'=0)")
                        Process1 : ("!u1&(c<N-1)" -> "1" : "(u1'=false)&(v1'=v2)")
                        Process1 : ("u1&!(p1=v2)&(c=N-1)" -> "1" : "(u1'=true)&(v1'=0)&(p1'=0)")
                        Process1 : ("u1&(p1=v2)&(c=N-1)" -> "1" : "(u1'=false)&(v1'=0)&(p1'=0)")
                        Process1 : ("!u1&(c=N-1)" -> "1" : "(u1'=false)&(v1'=0)")

                        Process2 : ("u2&!(p2=v1)&(c<N-1)" -> "1" : "(u2'=true)&(v2'=v1)")
                        Process2 : ("u2&(p2=v1)&(c<N-1)" -> "1" : "(u2'=false)&(v2'=v1)&(p2'=0)")
                        Process2 : ("!u2&(c<N-1)" -> "1" : "(u2'=false)&(v2'=v2)")
                        Process2 : ("u1&!(p2=v1)&(c=N-1)" -> "1" : "(u2'=true)&(v2'=0)&(p2'=0)")
                        Process2 : ("u2&(p2=v1)&(c=N-1)" -> "1" : "(u2'=false)&(v2'=0)&(p2'=0)")
                        Process2 : ("!u2&(c=N-1)" -> "1" : "(u2'=false)&(v2'=0)")

                        Process3 : ("u3&!(p3=v1)&(c<N-1)" -> "1" : "(u3'=true)&(v3'=v1)")
                        Process3 : ("u3&(p3=v1)&(c<N-1)" -> "1" : "(u3'=false)&(v3'=v1)&(p3'=0)")
                        Process3 : ("!u3&(c<N-1)" -> "1" : "(u3'=false)&(v3'=v3)")
                        Process3 : ("u1&!(p3=v1)&(c=N-1)" -> "1" : "(u3'=true)&(v3'=0)&(p3'=0)")
                        Process3 : ("u3&(p3=v1)&(c=N-1)" -> "1" : "(u3'=false)&(v3'=0)&(p3'=0)")
                        Process3 : ("!u3&(c=N-1)" -> "1" : "(u3'=false)&(v3'=0)")

                        Process4 : ("u4&!(p4=v1)&(c<N-1)" -> "1" : "(u4'=true)&(v4'=v1)")
                        Process4 : ("u4&(p4=v1)&(c<N-1)" -> "1" : "(u4'=false)&(v4'=v1)&(p4'=0)")
                        Process4 : ("!u4&(c<N-1)" -> "1" : "(u4'=false)&(v4'=v4)")
                        Process4 : ("u1&!(p4=v1)&(c=N-1)" -> "1" : "(u4'=true)&(v4'=0)&(p4'=0)")
                        Process4 : ("u4&(p4=v1)&(c=N-1)" -> "1" : "(u4'=false)&(v4'=0)&(p4'=0)")
                        Process4 : ("!u4&(c=N-1)" -> "1" : "(u4'=false)&(v4'=0)")

                     } . if "u1 | u2 | u3 | u4"@Counter then {
                            Counter -> Process[i] : (["1*1"] "(c'=c)" "(u[i]'=false)&(v[i]'=0)&(p[i]'=0)"
                            . allSynch {
                                                    Counter : (true -> "1" : "(c'=c)")
                                                    Process1 : (true -> "1" : " ")
                                                    Process2 : (true -> "1" : " ")
                                                    Process3 : (true -> "1" : " ")
                                                    Process4 : (true -> "1" : " ")
                                                 } . END)
                     }
                     else{
                            Counter -> Process[i] : (["1*1"] "(c'=1)" "(u[i]'=false)&(v[i]'=0)&(p[i]'=0)"  . Election)
                     }
}