
preamble
"dtmc"

"const N = 4;"
"const K = 3;"
endpreamble

n = 1;

Process1 ->
Process1 : "p1 : [0..4] init 0;", "v1 : [0..4] init 0;", "u1 : boolean init true;" ;

Process2 ->
Process2 : "p2 : [0..4] init 0;", "v2 : [0..4] init 0;", "u2 : boolean init true;" ;

Counter ->
Counter : "c : [1..3] init 0;" ;

{
Election := Process1 -> Process2 : (+["0.125*0.125"] "(p1'=0)&(v1'=0)&(u1'=true)" "(p2'=1)&(v2'=1)&(u2'=true)" . Election2
                                +["0.125*0.125"] "(p1'=1)&(v1'=1)&(u1'=true)" "(p2'=1)&(v2'=1)&(u2'=true)" . Election2
                                +["0.125*0.125"] "(p1'=2)&(v1'=2)&(u1'=true)" "(p2'=2)&(v2'=2)&(u2'=true)" . Election2
                                )


Election2 := if "(c<3)"@Counter, "(u1)&(p1!=v2)&(c<3)"@Process1, "(u2)|(p2!=v3)&(c<3)"@Process2 then {
                                                     Counter -> Process1,Process2: (["1*1"] "(c'=c+1)" "(u1'=true)&(v1'=v2)" "(u2'=true)&(v2'=v3)" .Election2)
                                                 }
                                                 else{
                                                     if "(c<3)"@Counter, "(u1)&(p1=v2)&(c<3)"@Process1, "(u2)&(p2=v3)&(c<3)"@Process2 then {
                                                        Counter -> Process1,Process2: (["1*1"] "(c'=c+1)" "(u1'=false)&(v1'=v2)&(p1'=0)" "(u2'=false)&(v2'=v3)&(p2'=0)" .Election2)
                                                     }
                                                     else{
                                                         if "(c<3)"@Counter, "(!u1)&(c<3)"@Process1, "(!u2)&(c<3)"@Process2 then {
                                                             Counter -> Process1,Process2: (["1*1"] "(c'=c+1)" "(u1'=false)&(v1'=v2)" "(u2'=false)&(v2'=v3)" .Election2)
                                                         }
                                                         else{
                                                             if "(c=3)"@Counter, "(u1)&(p1!=v2)&(c=3)"@Process1, "(u2)&(p2!=v3)&(c=3)"@Process2 then {
                                                                 Counter -> Process1,Process2: (["1*1"] "(c'=c)" "(u1'=true)&(v1'=0)&(p1'=0)"  "(u2'=true)&(v2'=0)&(p2'=0)" .Election3)
                                                             }
                                                             else{
                                                                 if "(c=3)"@Counter, "(u1)&(p1=v2)&(c=3)"@Process1, "(u2)&(p2=v3)&(c=3)"@Process2 then {
                                                                      Counter -> Process1,Process2: (["1*1"] "(c'=c)" "(u1'=false)&(v1'=0)&(p1'=0)"  "(u2'=false)&(v2'=0)&(p2'=0)" .Election3)
                                                                 }
                                                                 else{
                                                                     Counter -> Process1,Process2: (["1*1"] "(c'=c)" "(u1'=false)&(v1'=0)"  "(u2'=false)&(v2'=0)" .Election3)
                                                                 }
                                                             }
                                                         }
                                                     }
                                                 }

Election3 := if "(u1)|(u2)"@Counter then {
                 Counter -> Process1, Process2: (["1*1"] "(c'=c)"  "(u1'=false)&(v1'=0)&(p1'=0)" "(u2'=false)&(v2'=0)&(p2'=0)" .Election4)
             }
             else{
                 Counter -> Process1, Process2: (["1*1"] "(c'=1)"  "(u1'=false)&(v1'=0)&(p1'=0)" "(u2'=false)&(v2'=0)&(p2'=0)" .Election)
             }

Election4 := Counter -> Process1, Process2 : (["1*1"] " " " " " " .END)
}